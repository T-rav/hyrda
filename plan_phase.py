"""Plan phase — run planning agents on issues and post results."""

from __future__ import annotations

import asyncio
import logging

from analysis import PlanAnalyzer
from config import HydraFlowConfig
from events import EventBus
from issue_store import IssueStore
from memory import file_memory_suggestion
from models import GitHubIssue, PlanResult
from planner import PlannerRunner
from pr_manager import PRManager
from state import StateTracker

logger = logging.getLogger("hydraflow.plan_phase")


class PlanPhase:
    """Runs planning agents on issues and posts results."""

    def __init__(
        self,
        config: HydraFlowConfig,
        state: StateTracker,
        store: IssueStore,
        planners: PlannerRunner,
        prs: PRManager,
        bus: EventBus,
        stop_event: asyncio.Event,
    ) -> None:
        self._config = config
        self._state = state
        self._store = store
        self._planners = planners
        self._prs = prs
        self._bus = bus
        self._stop_event = stop_event

    async def plan_issues(self) -> list[PlanResult]:
        """Run planning agents on issues from the plan queue."""
        issues = self._store.get_plannable(self._config.batch_size)
        if not issues:
            return []

        semaphore = asyncio.Semaphore(self._config.max_planners)
        results: list[PlanResult] = []

        async def _plan_one(idx: int, issue: GitHubIssue) -> PlanResult:
            if self._stop_event.is_set():
                return PlanResult(issue_number=issue.number, error="stopped")

            async with semaphore:
                if self._stop_event.is_set():
                    return PlanResult(issue_number=issue.number, error="stopped")

                self._store.mark_active(issue.number, "plan")
                try:
                    result = await self._planners.plan(issue, worker_id=idx)

                    if result.already_satisfied:
                        # Issue is already satisfied — close with dup label
                        await self._prs.swap_pipeline_labels(
                            issue.number, self._config.dup_label[0]
                        )
                        await self._prs.post_comment(
                            issue.number,
                            f"## Already Satisfied\n\n"
                            f"The planner determined that this issue's requirements "
                            f"are already met by the existing codebase.\n\n"
                            f"{result.summary}\n\n"
                            f"---\n"
                            f"*Generated by HydraFlow Planner*",
                        )
                        await self._prs.close_issue(issue.number)
                        logger.info(
                            "Issue #%d closed as already satisfied",
                            issue.number,
                        )
                        return result

                    if result.success and result.plan:
                        # Post plan + branch as comment on the issue
                        branch = self._config.branch_for_issue(issue.number)
                        comment_body = (
                            f"## Implementation Plan\n\n"
                            f"{result.plan}\n\n"
                            f"**Branch:** `{branch}`\n\n"
                            f"---\n"
                            f"*Generated by HydraFlow Planner*"
                        )
                        await self._prs.post_comment(issue.number, comment_body)

                        # Run pre-implementation analysis
                        analyzer = PlanAnalyzer(
                            repo_root=self._config.repo_root,
                        )
                        analysis = analyzer.analyze(result.plan, issue.number)

                        # Post analysis comment
                        await self._prs.post_comment(
                            issue.number, analysis.format_comment()
                        )

                        # Swap labels: planner → ready for implementation
                        await self._prs.swap_pipeline_labels(
                            issue.number, self._config.ready_label[0]
                        )

                        # File new issues discovered during planning
                        for new_issue in result.new_issues:
                            if len(new_issue.body) < 50:
                                logger.warning(
                                    "Skipping discovered issue %r — body too short "
                                    "(%d chars, need ≥50)",
                                    new_issue.title,
                                    len(new_issue.body),
                                )
                                continue
                            labels = new_issue.labels or (
                                [self._config.planner_label[0]]
                                if self._config.planner_label
                                else []
                            )
                            await self._prs.create_issue(
                                new_issue.title, new_issue.body, labels
                            )
                            self._state.record_issue_created()

                        logger.info(
                            "Plan posted and labels swapped for issue #%d",
                            issue.number,
                        )
                    elif result.retry_attempted:
                        # Both plan attempts failed validation — escalate to HITL
                        error_list = "\n".join(
                            f"- {e}" for e in result.validation_errors
                        )
                        hitl_comment = (
                            f"## Plan Validation Failed\n\n"
                            f"The planner was unable to produce a valid plan "
                            f"after two attempts for issue #{issue.number}.\n\n"
                            f"**Validation errors:**\n{error_list}\n\n"
                            f"---\n"
                            f"*Generated by HydraFlow Planner*"
                        )
                        await self._prs.post_comment(issue.number, hitl_comment)
                        self._state.set_hitl_origin(
                            issue.number, self._config.planner_label[0]
                        )
                        self._state.set_hitl_cause(
                            issue.number,
                            "Plan validation failed after retry",
                        )
                        self._state.record_hitl_escalation()
                        await self._prs.swap_pipeline_labels(
                            issue.number, self._config.hitl_label[0]
                        )
                        logger.warning(
                            "Planning failed validation for issue #%d after retry — "
                            "escalated to HITL",
                            issue.number,
                        )
                    else:
                        logger.warning(
                            "Planning failed for issue #%d — skipping label swap",
                            issue.number,
                        )

                    # File memory suggestion if present in transcript
                    if result.transcript:
                        try:
                            await file_memory_suggestion(
                                result.transcript,
                                "planner",
                                f"issue #{issue.number}",
                                self._config,
                                self._prs,
                                self._state,
                            )
                        except Exception:
                            logger.exception(
                                "Failed to file memory suggestion for issue #%d",
                                issue.number,
                            )

                    return result
                finally:
                    self._store.mark_complete(issue.number)

        all_tasks = [
            asyncio.create_task(_plan_one(i, issue)) for i, issue in enumerate(issues)
        ]
        for task in asyncio.as_completed(all_tasks):
            results.append(await task)
            # Cancel remaining tasks if stop requested
            if self._stop_event.is_set():
                for t in all_tasks:
                    t.cancel()
                break

        return results
