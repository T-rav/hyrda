"""Implementation batch processing for the HydraFlow orchestrator."""

from __future__ import annotations

import asyncio
import logging
from pathlib import Path

from agent import AgentRunner
from config import HydraFlowConfig
from issue_store import IssueStore
from models import GitHubIssue, WorkerResult
from pr_manager import PRManager
from run_recorder import RunRecorder
from state import StateTracker
from worktree import WorktreeManager

logger = logging.getLogger("hydraflow.implement_phase")


class ImplementPhase:
    """Fetches ready issues and runs implementation agents concurrently."""

    def __init__(
        self,
        config: HydraFlowConfig,
        state: StateTracker,
        worktrees: WorktreeManager,
        agents: AgentRunner,
        prs: PRManager,
        store: IssueStore,
        stop_event: asyncio.Event,
        run_recorder: RunRecorder | None = None,
    ) -> None:
        self._config = config
        self._state = state
        self._worktrees = worktrees
        self._agents = agents
        self._prs = prs
        self._store = store
        self._stop_event = stop_event
        self._run_recorder = run_recorder
        self._active_issues: set[int] = set()

    async def _close_as_already_satisfied(self, issue: GitHubIssue) -> None:
        """Close an issue as already satisfied (no changes needed)."""
        for lbl in self._config.ready_label:
            await self._prs.remove_label(issue.number, lbl)
        await self._prs.add_labels(issue.number, self._config.dup_label)
        await self._prs.post_comment(
            issue.number,
            "## Already Satisfied\n\n"
            "The implementation agent found that no changes were needed — "
            "the issue's requirements appear to be already met by the "
            "existing codebase.\n\n"
            "---\n"
            "*Generated by HydraFlow Implementer*",
        )
        await self._prs.close_issue(issue.number)
        logger.info(
            "Issue #%d closed as already satisfied (zero commits)",
            issue.number,
        )

    async def run_batch(
        self,
        issues: list[GitHubIssue] | None = None,
    ) -> tuple[list[WorkerResult], list[GitHubIssue]]:
        """Run implementation agents on *issues* concurrently.

        If *issues* is ``None``, pulls from the ``IssueStore`` ready queue.
        Returns ``(worker_results, issues)`` so the caller has access
        to the issue list for downstream phases.
        """
        if issues is None:
            issues = self._store.get_implementable(2 * self._config.max_workers)
        if not issues:
            return [], []

        semaphore = asyncio.Semaphore(self._config.max_workers)
        results: list[WorkerResult] = []

        async def _worker(idx: int, issue: GitHubIssue) -> WorkerResult:
            if self._stop_event.is_set():
                return WorkerResult(
                    issue_number=issue.number,
                    branch=f"agent/issue-{issue.number}",
                    error="stopped",
                )

            async with semaphore:
                if self._stop_event.is_set():
                    return WorkerResult(
                        issue_number=issue.number,
                        branch=f"agent/issue-{issue.number}",
                        error="stopped",
                    )

                branch = f"agent/issue-{issue.number}"
                self._active_issues.add(issue.number)
                self._state.set_active_issue_numbers(list(self._active_issues))
                self._store.mark_active(issue.number, "implement")
                self._state.mark_issue(issue.number, "in_progress")
                self._state.set_branch(issue.number, branch)

                try:
                    return await self._worker_inner(idx, issue, branch)
                except Exception:
                    logger.exception("Worker failed for issue #%d", issue.number)
                    self._state.mark_issue(issue.number, "failed")
                    return WorkerResult(
                        issue_number=issue.number,
                        branch=branch,
                        error=f"Worker exception for issue #{issue.number}",
                    )
                finally:
                    self._active_issues.discard(issue.number)
                    self._state.set_active_issue_numbers(list(self._active_issues))
                    self._store.mark_complete(issue.number)

        all_tasks = [
            asyncio.create_task(_worker(i, issue)) for i, issue in enumerate(issues)
        ]
        for task in asyncio.as_completed(all_tasks):
            results.append(await task)
            # Cancel remaining tasks if stop requested
            if self._stop_event.is_set():
                for t in all_tasks:
                    t.cancel()
                break

        return results, issues

    async def _worker_inner(
        self, idx: int, issue: GitHubIssue, branch: str
    ) -> WorkerResult:
        """Core implementation logic — called inside the semaphore."""
        cap_result = await self._check_attempt_cap(issue, branch)
        if cap_result is not None:
            return cap_result

        # Start recording if a run recorder is available
        ctx = None
        if self._run_recorder is not None:
            try:
                ctx = self._run_recorder.start(issue.number)
                plan_text = self._read_plan_for_recording(issue.number)
                if plan_text:
                    ctx.save_plan(plan_text)
                ctx.save_config(self._config.model_dump(mode="json"))
            except Exception:
                logger.debug("Run recording setup failed", exc_info=True)
                ctx = None

        review_feedback = self._state.get_review_feedback(issue.number) or ""
        result = await self._run_implementation(issue, branch, idx, review_feedback)

        # Finalize the recording
        if ctx is not None:
            try:
                if result.transcript:
                    for line in result.transcript.splitlines():
                        ctx.append_transcript(line)
                outcome = "success" if result.success else "failed"
                ctx.finalize(outcome, error=result.error)
            except Exception:
                logger.debug("Run recording finalize failed", exc_info=True)

        is_retry = bool(review_feedback)
        return await self._handle_implementation_result(issue, result, is_retry)

    def _read_plan_for_recording(self, issue_number: int) -> str:
        """Read the plan file for *issue_number*, returning empty string on failure."""
        plan_path = (
            self._config.repo_root / ".hydra" / "plans" / f"issue-{issue_number}.md"
        )
        try:
            return plan_path.read_text()
        except OSError:
            return ""

    async def _check_attempt_cap(
        self, issue: GitHubIssue, branch: str
    ) -> WorkerResult | None:
        """Check per-issue attempt cap.  Returns a WorkerResult on cap exceeded, else None."""
        attempts = self._state.increment_issue_attempts(issue.number)
        if attempts <= self._config.max_issue_attempts:
            return None

        last_meta = self._state.get_worker_result_meta(issue.number)
        last_error = (
            last_meta.get("error", "No error details available")
            or "No error details available"
        )
        await self._prs.post_comment(
            issue.number,
            f"**Implementation attempt cap exceeded** — "
            f"{attempts - 1} attempt(s) exhausted "
            f"(max {self._config.max_issue_attempts}).\n\n"
            f"Last error: {last_error}\n\n"
            f"Escalating to human review.",
        )
        self._state.set_hitl_origin(issue.number, self._config.ready_label[0])
        self._state.set_hitl_cause(
            issue.number,
            f"Implementation attempt cap exceeded after {attempts - 1} attempt(s)",
        )
        self._state.record_hitl_escalation()
        await self._prs.swap_pipeline_labels(issue.number, self._config.hitl_label[0])
        self._state.mark_issue(issue.number, "failed")
        return WorkerResult(
            issue_number=issue.number,
            branch=branch,
            error=f"Implementation attempt cap exceeded ({attempts - 1} attempts)",
        )

    async def _run_implementation(
        self,
        issue: GitHubIssue,
        branch: str,
        worker_id: int,
        review_feedback: str,
    ) -> WorkerResult:
        """Set up worktree, push branch, run agent, record metrics."""
        wt_path = self._config.worktree_base / f"issue-{issue.number}"
        if wt_path.is_dir():
            logger.info("Resuming existing worktree for issue #%d", issue.number)
        else:
            wt_path = await self._worktrees.create(issue.number, branch)
        self._state.set_worktree(issue.number, str(wt_path))

        await self._prs.push_branch(wt_path, branch)
        await self._prs.post_comment(
            issue.number,
            f"**Branch:** [`{branch}`](https://github.com/"
            f"{self._config.repo}/tree/{branch})\n\n"
            f"Implementation in progress.",
        )

        result = await self._agents.run(
            issue,
            wt_path,
            branch,
            worker_id=worker_id,
            review_feedback=review_feedback,
        )

        if review_feedback:
            self._state.clear_review_feedback(issue.number)

        if result.duration_seconds > 0:
            self._state.record_implementation_duration(result.duration_seconds)
        if result.quality_fix_attempts > 0:
            self._state.record_quality_fix_rounds(result.quality_fix_attempts)
            for _ in range(result.quality_fix_attempts):
                self._state.record_stage_retry(issue.number, "quality_fix")

        self._state.set_worker_result_meta(
            issue.number,
            {
                "quality_fix_attempts": result.quality_fix_attempts,
                "duration_seconds": result.duration_seconds,
                "error": result.error,
                "commits": result.commits,
            },
        )

        return result

    async def _handle_implementation_result(
        self, issue: GitHubIssue, result: WorkerResult, is_retry: bool
    ) -> WorkerResult:
        """Handle the result of an agent run: close, create PR, swap labels."""
        # Zero-commit: issue is already satisfied
        if (
            not result.success
            and result.error == "No commits found on branch"
            and result.commits == 0
        ):
            await self._close_as_already_satisfied(issue)
            self._state.mark_issue(issue.number, "already_satisfied")
            return result

        # Push final commits and create PR
        if result.worktree_path:
            pushed = await self._prs.push_branch(
                Path(result.worktree_path), result.branch
            )
            if pushed:
                pr = None
                if not is_retry:
                    draft = not result.success
                    pr = await self._prs.create_pr(issue, result.branch, draft=draft)
                    result.pr_info = pr

                if result.success:
                    await self._prs.swap_pipeline_labels(
                        issue.number,
                        self._config.review_label[0],
                        pr_number=pr.number if pr and pr.number > 0 else None,
                    )

        status = "success" if result.success else "failed"
        self._state.mark_issue(issue.number, status)
        return result
