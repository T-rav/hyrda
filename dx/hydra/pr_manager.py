"""Pull request lifecycle management via the ``gh`` CLI."""

from __future__ import annotations

import asyncio
import json
import logging
import os
from pathlib import Path

from config import HydraConfig
from events import EventBus, EventType, HydraEvent
from models import GitHubIssue, PRInfo

logger = logging.getLogger("hydra.pr_manager")


class PRManager:
    """Pushes branches, creates PRs, merges, and manages labels."""

    def __init__(self, config: HydraConfig, event_bus: EventBus) -> None:
        self._config = config
        self._bus = event_bus
        self._repo = config.repo

    async def push_branch(self, worktree_path: Path, branch: str) -> bool:
        """Push *branch* to origin from *worktree_path*.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would push branch %s", branch)
            return True

        try:
            await self._run(
                "git",
                "push",
                "-u",
                "origin",
                branch,
                cwd=worktree_path,
            )
            return True
        except RuntimeError as exc:
            logger.error("Push failed for %s: %s", branch, exc)
            return False

    async def create_pr(
        self,
        issue: GitHubIssue,
        branch: str,
        *,
        draft: bool = False,
    ) -> PRInfo:
        """Create a PR for *branch* linked to *issue*.

        Returns a :class:`PRInfo` with the PR number and URL.
        """
        title = f"Fixes #{issue.number}: {issue.title}"
        if len(title) > 70:
            title = title[:67] + "..."

        body = (
            f"## Summary\n\n"
            f"Automated implementation for #{issue.number}.\n\n"
            f"## Issue\n\n{issue.title}\n\n"
            f"## Test plan\n\n"
            f"- [ ] Unit tests pass (`make test-fast`)\n"
            f"- [ ] Linting passes (`make lint`)\n"
            f"- [ ] Manual review of changes\n\n"
            f"---\n"
            f"Generated by Hydra"
        )

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would create %sPR for issue #%d",
                "draft " if draft else "",
                issue.number,
            )
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                url="",
                draft=draft,
            )

        cmd = [
            "gh",
            "pr",
            "create",
            "--repo",
            self._repo,
            "--head",
            branch,
            "--base",
            self._config.main_branch,
            "--title",
            title,
            "--body",
            body,
        ]
        if draft:
            cmd.append("--draft")

        try:
            output = await self._run(*cmd, cwd=self._config.repo_root)
            # gh pr create --json would be better, but the URL is in stdout
            pr_url = output.strip()

            # Get PR number from URL (e.g., https://github.com/org/repo/pull/123)
            pr_number = int(pr_url.rstrip("/").split("/")[-1])

            pr_info = PRInfo(
                number=pr_number,
                issue_number=issue.number,
                branch=branch,
                url=pr_url,
                draft=draft,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.PR_CREATED,
                    data={
                        "pr": pr_number,
                        "issue": issue.number,
                        "branch": branch,
                        "draft": draft,
                        "url": pr_url,
                    },
                )
            )

            return pr_info

        except RuntimeError as exc:
            logger.error("PR creation failed for issue #%d: %s", issue.number, exc)
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                draft=draft,
            )

    async def merge_pr(self, pr_number: int) -> bool:
        """Auto-merge PR via squash merge with branch deletion.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would merge PR #%d", pr_number)
            return True

        try:
            await self._run(
                "gh",
                "pr",
                "merge",
                str(pr_number),
                "--repo",
                self._repo,
                "--squash",
                "--auto",
                "--delete-branch",
                cwd=self._config.repo_root,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.MERGE_UPDATE,
                    data={"pr": pr_number, "status": "merge_requested"},
                )
            )
            return True
        except RuntimeError as exc:
            logger.error("Merge failed for PR #%d: %s", pr_number, exc)
            return False

    async def add_labels(self, issue_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub issue."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await self._run(
                    "gh",
                    "issue",
                    "edit",
                    str(issue_number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to issue #%d: %s",
                    label,
                    issue_number,
                    exc,
                )

    async def remove_label(self, issue_number: int, label: str) -> None:
        """Remove *label* from a GitHub issue."""
        if self._config.dry_run:
            return
        try:
            await self._run(
                "gh",
                "issue",
                "edit",
                str(issue_number),
                "--repo",
                self._repo,
                "--remove-label",
                label,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not remove label %r from issue #%d: %s",
                label,
                issue_number,
                exc,
            )

    async def get_pr_diff(self, pr_number: int) -> str:
        """Fetch the diff for *pr_number*."""
        try:
            return await self._run(
                "gh",
                "pr",
                "diff",
                str(pr_number),
                "--repo",
                self._repo,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.error("Could not get diff for PR #%d: %s", pr_number, exc)
            return ""

    async def get_pr_status(self, pr_number: int) -> dict[str, object]:
        """Fetch PR status as JSON."""
        try:
            raw = await self._run(
                "gh",
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "number,state,mergeable,title,isDraft",
                cwd=self._config.repo_root,
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.error("Could not get status for PR #%d: %s", pr_number, exc)
            return {}

    async def pull_main(self) -> bool:
        """Pull latest main into the local repo."""
        if self._config.dry_run:
            logger.info("[dry-run] Would pull main")
            return True
        try:
            await self._run(
                "git",
                "pull",
                "origin",
                self._config.main_branch,
                cwd=self._config.repo_root,
            )
            return True
        except RuntimeError as exc:
            logger.error("Pull main failed: %s", exc)
            return False

    # --- subprocess helper ---

    @staticmethod
    async def _run(*cmd: str, cwd: Path) -> str:
        env = {**os.environ}
        env.pop("CLAUDECODE", None)

        proc = await asyncio.create_subprocess_exec(
            *cmd,
            cwd=str(cwd),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=env,
        )
        stdout, stderr = await proc.communicate()
        if proc.returncode != 0:
            raise RuntimeError(
                f"Command {cmd!r} failed (rc={proc.returncode}): "
                f"{stderr.decode().strip()}"
            )
        return stdout.decode().strip()
