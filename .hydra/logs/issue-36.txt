{"type":"system","subtype":"init","cwd":"/Users/travisf/Documents/projects/hyrda-worktrees/issue-36","session_id":"95e5a686-e325-4661-b11b-31c542c127c9","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","TaskStop","AskUserQuestion","Skill","EnterPlanMode","ToolSearch"],"mcp_servers":[],"model":"claude-opus-4-6","permissionMode":"bypassPermissions","slash_commands":["keybindings-help","debug","gh-issue","code-review","audit-integration-tests","audit-hooks","audit-tests","gh-issue","audit-integration-tests","audit-hooks","compact","context","cost","init","pr-comments","release-notes","review","security-review","insights"],"apiKeySource":"none","claude_code_version":"2.1.47","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","code-audit","code-quality-enforcer","test-audit"],"skills":["keybindings-help","debug"],"plugins":[{"name":"pyright-lsp","path":"/Users/travisf/.claude/plugins/cache/claude-plugins-official/pyright-lsp/1.0.0"}],"uuid":"f245c439-bd66-498a-951f-f322d7561d3f","fast_mode_state":"off"}
{"type":"rate_limit_event","rate_limit_info":{"status":"allowed","resetsAt":1771545600,"rateLimitType":"five_hour","overageStatus":"rejected","overageDisabledReason":"org_level_disabled","isUsingOverage":false},"uuid":"9ff16099-c3b0-4ef2-b237-d87231394cba","session_id":"95e5a686-e325-4661-b11b-31c542c127c9"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01SDVmXgHCyo58RkP9p9ykUr","type":"message","role":"assistant","content":[{"type":"text","text":"\n\nI'll start by reading the existing source and test files to understand the current code and test patterns."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":4665,"cache_read_input_tokens":18365,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4665},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"95e5a686-e325-4661-b11b-31c542c127c9","uuid":"5c89c57c-8ab3-4f83-9ac9-d4607a17ddd1"}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01SDVmXgHCyo58RkP9p9ykUr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AaybDoqw2Xfzi7GGjx7E6j","name":"Read","input":{"file_path":"/Users/travisf/Documents/projects/hyrda-worktrees/issue-36/stream_parser.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":4665,"cache_read_input_tokens":18365,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4665},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"95e5a686-e325-4661-b11b-31c542c127c9","uuid":"2b6966f2-eb0a-4785-acce-b987a03676df"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AaybDoqw2Xfzi7GGjx7E6j","type":"tool_result","content":"     1→\"\"\"Parse Claude Code ``stream-json`` output into human-readable transcript lines.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import json\n     6→\n     7→\n     8→class StreamParser:\n     9→    \"\"\"Stateful parser for ``claude -p --output-format stream-json``.\n    10→\n    11→    The stream-json format emits one JSON object per line:\n    12→    - ``assistant`` events contain a ``message.content`` array with\n    13→      ``text`` and ``tool_use`` blocks.  Each event is a *cumulative*\n    14→      snapshot — the same content repeats as the turn grows.\n    15→    - ``user`` events carry tool results (we show a summary).\n    16→    - ``result`` events carry the final output.\n    17→\n    18→    This parser tracks what it has already shown so each call to\n    19→    :meth:`parse` returns only *new* display content.\n    20→    \"\"\"\n    21→\n    22→    def __init__(self) -> None:\n    23→        self._seen_tool_ids: set[str] = set()\n    24→        self._prev_text_len: int = 0\n    25→        self._prev_msg_id: str = \"\"\n    26→\n    27→    def parse(self, raw_line: str) -> tuple[str, str | None]:\n    28→        \"\"\"Parse a single stream-json line.\n    29→\n    30→        Returns ``(display_text, result_text)``:\n    31→        - *display_text* is human-readable text for the live transcript.\n    32→        - *result_text* is non-None only for the final ``result`` event.\n    33→        \"\"\"\n    34→        try:\n    35→            event = json.loads(raw_line)\n    36→        except (json.JSONDecodeError, TypeError):\n    37→            return (raw_line, None)\n    38→\n    39→        event_type = event.get(\"type\", \"\")\n    40→\n    41→        if event_type == \"assistant\":\n    42→            return self._parse_assistant(event), None\n    43→\n    44→        if event_type == \"result\":\n    45→            return (\"\", event.get(\"result\", \"\"))\n    46→\n    47→        if event_type == \"user\":\n    48→            return self._parse_user(event), None\n    49→\n    50→        return (\"\", None)\n    51→\n    52→    def _parse_assistant(self, event: dict) -> str:  # type: ignore[type-arg]\n    53→        \"\"\"Extract new content from an assistant message event.\"\"\"\n    54→        message = event.get(\"message\", {})\n    55→        msg_id = message.get(\"id\", \"\")\n    56→        content = message.get(\"content\", [])\n    57→\n    58→        # Reset text tracking when a new turn starts\n    59→        if msg_id != self._prev_msg_id:\n    60→            self._prev_text_len = 0\n    61→            self._prev_msg_id = msg_id\n    62→\n    63→        parts: list[str] = []\n    64→\n    65→        # Collect text delta and new tool_use blocks\n    66→        full_text = \"\"\n    67→        for block in content:\n    68→            if not isinstance(block, dict):\n    69→                continue\n    70→            if block.get(\"type\") == \"text\":\n    71→                full_text += block.get(\"text\", \"\")\n    72→            elif block.get(\"type\") == \"tool_use\":\n    73→                tool_id = block.get(\"id\", \"\")\n    74→                if tool_id and tool_id not in self._seen_tool_ids:\n    75→                    self._seen_tool_ids.add(tool_id)\n    76→                    name = block.get(\"name\", \"?\")\n    77→                    tool_input = block.get(\"input\", {})\n    78→                    parts.append(f\"  → {name}: {_summarize_input(name, tool_input)}\")\n    79→\n    80→        # Emit text delta\n    81→        if len(full_text) > self._prev_text_len:\n    82→            delta = full_text[self._prev_text_len :].strip()\n    83→            self._prev_text_len = len(full_text)\n    84→            if delta:\n    85→                parts.insert(0, delta)\n    86→\n    87→        return \"\\n\".join(parts)\n    88→\n    89→    def _parse_user(self, event: dict) -> str:  # type: ignore[type-arg]\n    90→        \"\"\"Extract a brief summary from a user (tool result) event.\"\"\"\n    91→        message = event.get(\"message\", {})\n    92→        content = message.get(\"content\", [])\n    93→        for block in content:\n    94→            if isinstance(block, dict) and block.get(\"type\") == \"tool_result\":\n    95→                # Show a brief indicator that a tool returned\n    96→                content_val = block.get(\"content\", \"\")\n    97→                if isinstance(content_val, str) and content_val:\n    98→                    preview = content_val[:80].replace(\"\\n\", \" \")\n    99→                    return f\"    ← {preview}{'…' if len(content_val) > 80 else ''}\"\n   100→        return \"\"\n   101→\n   102→\n   103→# Stateless convenience function (for tests and simple use cases)\n   104→def parse_stream_event(raw_line: str) -> tuple[str, str | None]:\n   105→    \"\"\"Stateless single-event parse — no delta tracking.\"\"\"\n   106→    try:\n   107→        event = json.loads(raw_line)\n   108→    except (json.JSONDecodeError, TypeError):\n   109→        return (raw_line, None)\n   110→\n   111→    event_type = event.get(\"type\", \"\")\n   112→\n   113→    if event_type == \"assistant\":\n   114→        message = event.get(\"message\", {})\n   115→        content = message.get(\"content\", [])\n   116→        parts: list[str] = []\n   117→        for block in content:\n   118→            if not isinstance(block, dict):\n   119→                continue\n   120→            if block.get(\"type\") == \"text\":\n   121→                text = block.get(\"text\", \"\").strip()\n   122→                if text:\n   123→                    parts.append(text)\n   124→            elif block.get(\"type\") == \"tool_use\":\n   125→                name = block.get(\"name\", \"?\")\n   126→                tool_input = block.get(\"input\", {})\n   127→                parts.append(f\"  → {name}: {_summarize_input(name, tool_input)}\")\n   128→        return (\"\\n\".join(parts), None)\n   129→\n   130→    if event_type == \"result\":\n   131→        return (\"\", event.get(\"result\", \"\"))\n   132→\n   133→    return (\"\", None)\n   134→\n   135→\n   136→def _summarize_input(name: str, tool_input: dict) -> str:  # type: ignore[type-arg]  # noqa: PLR0911\n   137→    \"\"\"One-line summary of a tool call's input.\"\"\"\n   138→    if name in (\"Read\", \"read\"):\n   139→        return tool_input.get(\"file_path\", str(tool_input))[:120]\n   140→    if name in (\"Edit\", \"edit\"):\n   141→        return tool_input.get(\"file_path\", \"?\")[:120]\n   142→    if name in (\"Write\", \"write\"):\n   143→        return tool_input.get(\"file_path\", str(tool_input))[:120]\n   144→    if name in (\"Glob\", \"glob\"):\n   145→        return tool_input.get(\"pattern\", str(tool_input))[:120]\n   146→    if name in (\"Grep\", \"grep\"):\n   147→        pattern = tool_input.get(\"pattern\", \"\")\n   148→        path = tool_input.get(\"path\", \".\")\n   149→        return f\"/{pattern}/ in {path}\"[:120]\n   150→    if name in (\"Bash\", \"bash\"):\n   151→        return tool_input.get(\"command\", str(tool_input))[:120]\n   152→    if name in (\"Task\", \"task\"):\n   153→        desc = tool_input.get(\"description\", \"\")\n   154→        agent = tool_input.get(\"subagent_type\", \"\")\n   155→        return f\"{agent}: {desc}\"[:120] if agent else desc[:120]\n   156→    # Generic fallback\n   157→    summary = str(tool_input)\n   158→    return summary[:120] + (\"...\" if len(summary) > 120 else \"\")\n   159→"}]},"parent_tool_use_id":null,"session_id":"95e5a686-e325-4661-b11b-31c542c127c9","uuid":"9967280b-58b5-4fc8-98a9-ff28ef7ec98f","tool_use_result":{"type":"text","file":{"filePath":"/Users/travisf/Documents/projects/hyrda-worktrees/issue-36/stream_parser.py","content":"\"\"\"Parse Claude Code ``stream-json`` output into human-readable transcript lines.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\n\n\nclass StreamParser:\n    \"\"\"Stateful parser for ``claude -p --output-format stream-json``.\n\n    The stream-json format emits one JSON object per line:\n    - ``assistant`` events contain a ``message.content`` array with\n      ``text`` and ``tool_use`` blocks.  Each event is a *cumulative*\n      snapshot — the same content repeats as the turn grows.\n    - ``user`` events carry tool results (we show a summary).\n    - ``result`` events carry the final output.\n\n    This parser tracks what it has already shown so each call to\n    :meth:`parse` returns only *new* display content.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._seen_tool_ids: set[str] = set()\n        self._prev_text_len: int = 0\n        self._prev_msg_id: str = \"\"\n\n    def parse(self, raw_line: str) -> tuple[str, str | None]:\n        \"\"\"Parse a single stream-json line.\n\n        Returns ``(display_text, result_text)``:\n        - *display_text* is human-readable text for the live transcript.\n        - *result_text* is non-None only for the final ``result`` event.\n        \"\"\"\n        try:\n            event = json.loads(raw_line)\n        except (json.JSONDecodeError, TypeError):\n            return (raw_line, None)\n\n        event_type = event.get(\"type\", \"\")\n\n        if event_type == \"assistant\":\n            return self._parse_assistant(event), None\n\n        if event_type == \"result\":\n            return (\"\", event.get(\"result\", \"\"))\n\n        if event_type == \"user\":\n            return self._parse_user(event), None\n\n        return (\"\", None)\n\n    def _parse_assistant(self, event: dict) -> str:  # type: ignore[type-arg]\n        \"\"\"Extract new content from an assistant message event.\"\"\"\n        message = event.get(\"message\", {})\n        msg_id = message.get(\"id\", \"\")\n        content = message.get(\"content\", [])\n\n        # Reset text tracking when a new turn starts\n        if msg_id != self._prev_msg_id:\n            self._prev_text_len = 0\n            self._prev_msg_id = msg_id\n\n        parts: list[str] = []\n\n        # Collect text delta and new tool_use blocks\n        full_text = \"\"\n        for block in content:\n            if not isinstance(block, dict):\n                continue\n            if block.get(\"type\") == \"text\":\n                full_text += block.get(\"text\", \"\")\n            elif block.get(\"type\") == \"tool_use\":\n                tool_id = block.get(\"id\", \"\")\n                if tool_id and tool_id not in self._seen_tool_ids:\n                    self._seen_tool_ids.add(tool_id)\n                    name = block.get(\"name\", \"?\")\n                    tool_input = block.get(\"input\", {})\n                    parts.append(f\"  → {name}: {_summarize_input(name, tool_input)}\")\n\n        # Emit text delta\n        if len(full_text) > self._prev_text_len:\n            delta = full_text[self._prev_text_len :].strip()\n            self._prev_text_len = len(full_text)\n            if delta:\n                parts.insert(0, delta)\n\n        return \"\\n\".join(parts)\n\n    def _parse_user(self, event: dict) -> str:  # type: ignore[type-arg]\n        \"\"\"Extract a brief summary from a user (tool result) event.\"\"\"\n        message = event.get(\"message\", {})\n        content = message.get(\"content\", [])\n        for block in content:\n            if isinstance(block, dict) and block.get(\"type\") == \"tool_result\":\n                # Show a brief indicator that a tool returned\n                content_val = block.get(\"content\", \"\")\n                if isinstance(content_val, str) and content_val:\n                    preview = content_val[:80].replace(\"\\n\", \" \")\n                    return f\"    ← {preview}{'…' if len(content_val) > 80 else ''}\"\n        return \"\"\n\n\n# Stateless convenience function (for tests and simple use cases)\ndef parse_stream_event(raw_line: str) -> tuple[str, str | None]:\n    \"\"\"Stateless single-event parse — no delta tracking.\"\"\"\n    try:\n        event = json.loads(raw_line)\n    except (json.JSONDecodeError, TypeError):\n        return (raw_line, None)\n\n    event_type = event.get(\"type\", \"\")\n\n    if event_type == \"assistant\":\n        message = event.get(\"message\", {})\n        content = message.get(\"content\", [])\n        parts: list[str] = []\n        for block in content:\n            if not isinstance(block, dict):\n                continue\n            if block.get(\"type\") == \"text\":\n                text = block.get(\"text\", \"\").strip()\n                if text:\n                    parts.append(text)\n            elif block.get(\"type\") == \"tool_use\":\n                name = block.get(\"name\", \"?\")\n                tool_input = block.get(\"input\", {})\n                parts.append(f\"  → {name}: {_summarize_input(name, tool_input)}\")\n        return (\"\\n\".join(parts), None)\n\n    if event_type == \"result\":\n        return (\"\", event.get(\"result\", \"\"))\n\n    return (\"\", None)\n\n\ndef _summarize_input(name: str, tool_input: dict) -> str:  # type: ignore[type-arg]  # noqa: PLR0911\n    \"\"\"One-line summary of a tool call's input.\"\"\"\n    if name in (\"Read\", \"read\"):\n        return tool_input.get(\"file_path\", str(tool_input))[:120]\n    if name in (\"Edit\", \"edit\"):\n        return tool_input.get(\"file_path\", \"?\")[:120]\n    if name in (\"Write\", \"write\"):\n        return tool_input.get(\"file_path\", str(tool_input))[:120]\n    if name in (\"Glob\", \"glob\"):\n        return tool_input.get(\"pattern\", str(tool_input))[:120]\n    if name in (\"Grep\", \"grep\"):\n        pattern = tool_input.get(\"pattern\", \"\")\n        path = tool_input.get(\"path\", \".\")\n        return f\"/{pattern}/ in {path}\"[:120]\n    if name in (\"Bash\", \"bash\"):\n        return tool_input.get(\"command\", str(tool_input))[:120]\n    if name in (\"Task\", \"task\"):\n        desc = tool_input.get(\"description\", \"\")\n        agent = tool_input.get(\"subagent_type\", \"\")\n        return f\"{agent}: {desc}\"[:120] if agent else desc[:120]\n    # Generic fallback\n    summary = str(tool_input)\n    return summary[:120] + (\"...\" if len(summary) > 120 else \"\")\n","numLines":159,"startLine":1,"totalLines":159}}}
{"type":"assistant","message":{"model":"claude-opus-4-6","id":"msg_01SDVmXgHCyo58RkP9p9ykUr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012ariHp46ghDGxsXN356BaU","name":"Read","input":{"file_path":"/Users/travisf/Documents/projects/hyrda-worktrees/issue-36/tests/test_stream_parser.py"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":4665,"cache_read_input_tokens":18365,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":4665},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"95e5a686-e325-4661-b11b-31c542c127c9","uuid":"400f1f91-01cb-4985-b84e-8c7b3f1d4e08"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012ariHp46ghDGxsXN356BaU","type":"tool_result","content":"     1→\"\"\"Tests for dx/hydra/stream_parser.py.\"\"\"\n     2→\n     3→from __future__ import annotations\n     4→\n     5→import json\n     6→import sys\n     7→from pathlib import Path\n     8→\n     9→sys.path.insert(0, str(Path(__file__).parent.parent))\n    10→\n    11→from stream_parser import StreamParser, _summarize_input, parse_stream_event\n    12→\n    13→# ===========================================================================\n    14→# Stateless parse_stream_event\n    15→# ===========================================================================\n    16→\n    17→\n    18→def test_plain_text_passes_through():\n    19→    display, result = parse_stream_event(\"Hello world\")\n    20→    assert display == \"Hello world\"\n    21→    assert result is None\n    22→\n    23→\n    24→def test_empty_string():\n    25→    display, result = parse_stream_event(\"\")\n    26→    assert display == \"\"\n    27→    assert result is None\n    28→\n    29→\n    30→def test_invalid_json_passes_through():\n    31→    display, result = parse_stream_event(\"{not valid json\")\n    32→    assert display == \"{not valid json\"\n    33→    assert result is None\n    34→\n    35→\n    36→def test_assistant_text_content():\n    37→    event = {\n    38→        \"type\": \"assistant\",\n    39→        \"message\": {\n    40→            \"id\": \"msg_1\",\n    41→            \"content\": [{\"type\": \"text\", \"text\": \"Let me explore the codebase.\"}],\n    42→        },\n    43→    }\n    44→    display, result = parse_stream_event(json.dumps(event))\n    45→    assert display == \"Let me explore the codebase.\"\n    46→    assert result is None\n    47→\n    48→\n    49→def test_assistant_whitespace_only_text():\n    50→    event = {\n    51→        \"type\": \"assistant\",\n    52→        \"message\": {\"id\": \"msg_1\", \"content\": [{\"type\": \"text\", \"text\": \"   \\n\\n\"}]},\n    53→    }\n    54→    display, _ = parse_stream_event(json.dumps(event))\n    55→    assert display.strip() == \"\"\n    56→\n    57→\n    58→def test_assistant_tool_use_in_content():\n    59→    \"\"\"Tool use blocks in message.content are displayed.\"\"\"\n    60→    event = {\n    61→        \"type\": \"assistant\",\n    62→        \"message\": {\n    63→            \"id\": \"msg_1\",\n    64→            \"content\": [\n    65→                {\n    66→                    \"type\": \"tool_use\",\n    67→                    \"id\": \"toolu_1\",\n    68→                    \"name\": \"Read\",\n    69→                    \"input\": {\"file_path\": \"/src/models.py\"},\n    70→                },\n    71→            ],\n    72→        },\n    73→    }\n    74→    display, _ = parse_stream_event(json.dumps(event))\n    75→    assert \"Read\" in display\n    76→    assert \"/src/models.py\" in display\n    77→\n    78→\n    79→def test_assistant_tool_use_grep():\n    80→    event = {\n    81→        \"type\": \"assistant\",\n    82→        \"message\": {\n    83→            \"id\": \"msg_1\",\n    84→            \"content\": [\n    85→                {\n    86→                    \"type\": \"tool_use\",\n    87→                    \"id\": \"toolu_2\",\n    88→                    \"name\": \"Grep\",\n    89→                    \"input\": {\"pattern\": \"class Foo\", \"path\": \"/src\"},\n    90→                },\n    91→            ],\n    92→        },\n    93→    }\n    94→    display, _ = parse_stream_event(json.dumps(event))\n    95→    assert \"Grep\" in display\n    96→    assert \"class Foo\" in display\n    97→\n    98→\n    99→def test_assistant_tool_use_bash():\n   100→    event = {\n   101→        \"type\": \"assistant\",\n   102→        \"message\": {\n   103→            \"id\": \"msg_1\",\n   104→            \"content\": [\n   105→                {\n   106→                    \"type\": \"tool_use\",\n   107→                    \"id\": \"toolu_3\",\n   108→                    \"name\": \"Bash\",\n   109→                    \"input\": {\"command\": \"make test\"},\n   110→                },\n   111→            ],\n   112→        },\n   113→    }\n   114→    display, _ = parse_stream_event(json.dumps(event))\n   115→    assert \"Bash\" in display\n   116→    assert \"make test\" in display\n   117→\n   118→\n   119→def test_assistant_mixed_text_and_tool():\n   120→    event = {\n   121→        \"type\": \"assistant\",\n   122→        \"message\": {\n   123→            \"id\": \"msg_1\",\n   124→            \"content\": [\n   125→                {\"type\": \"text\", \"text\": \"Looking at the file.\"},\n   126→                {\n   127→                    \"type\": \"tool_use\",\n   128→                    \"id\": \"toolu_4\",\n   129→                    \"name\": \"Read\",\n   130→                    \"input\": {\"file_path\": \"/a.py\"},\n   131→                },\n   132→            ],\n   133→        },\n   134→    }\n   135→    display, _ = parse_stream_event(json.dumps(event))\n   136→    assert \"Looking at the file.\" in display\n   137→    assert \"Read\" in display\n   138→\n   139→\n   140→def test_assistant_task_tool_shows_agent_type():\n   141→    event = {\n   142→        \"type\": \"assistant\",\n   143→        \"message\": {\n   144→            \"id\": \"msg_1\",\n   145→            \"content\": [\n   146→                {\n   147→                    \"type\": \"tool_use\",\n   148→                    \"id\": \"toolu_5\",\n   149→                    \"name\": \"Task\",\n   150→                    \"input\": {\n   151→                        \"description\": \"Explore code\",\n   152→                        \"subagent_type\": \"Explore\",\n   153→                    },\n   154→                },\n   155→            ],\n   156→        },\n   157→    }\n   158→    display, _ = parse_stream_event(json.dumps(event))\n   159→    assert \"Task\" in display\n   160→    assert \"Explore\" in display\n   161→\n   162→\n   163→def test_result_event():\n   164→    event = {\n   165→        \"type\": \"result\",\n   166→        \"subtype\": \"success\",\n   167→        \"result\": \"PLAN_START\\nStep 1\\nPLAN_END\\nSUMMARY: done\",\n   168→    }\n   169→    display, result = parse_stream_event(json.dumps(event))\n   170→    assert display == \"\"\n   171→    assert result == \"PLAN_START\\nStep 1\\nPLAN_END\\nSUMMARY: done\"\n   172→\n   173→\n   174→def test_result_event_empty():\n   175→    event = {\"type\": \"result\", \"result\": \"\"}\n   176→    display, result = parse_stream_event(json.dumps(event))\n   177→    assert display == \"\"\n   178→    assert result == \"\"\n   179→\n   180→\n   181→def test_system_event_skipped():\n   182→    event = {\"type\": \"system\", \"subtype\": \"init\", \"session_id\": \"abc\"}\n   183→    display, result = parse_stream_event(json.dumps(event))\n   184→    assert display == \"\"\n   185→    assert result is None\n   186→\n   187→\n   188→def test_unknown_event_skipped():\n   189→    event = {\"type\": \"something_else\", \"data\": 123}\n   190→    display, result = parse_stream_event(json.dumps(event))\n   191→    assert display == \"\"\n   192→    assert result is None\n   193→\n   194→\n   195→def test_assistant_tool_use_edit():\n   196→    \"\"\"Edit tool displays file_path only, not old/new text.\"\"\"\n   197→    event = {\n   198→        \"type\": \"assistant\",\n   199→        \"message\": {\n   200→            \"id\": \"msg_1\",\n   201→            \"content\": [\n   202→                {\n   203→                    \"type\": \"tool_use\",\n   204→                    \"id\": \"toolu_edit\",\n   205→                    \"name\": \"Edit\",\n   206→                    \"input\": {\n   207→                        \"file_path\": \"/src/models.py\",\n   208→                        \"old_text\": \"old code here\",\n   209→                        \"new_text\": \"new code here\",\n   210→                    },\n   211→                },\n   212→            ],\n   213→        },\n   214→    }\n   215→    display, _ = parse_stream_event(json.dumps(event))\n   216→    assert \"Edit\" in display\n   217→    assert \"/src/models.py\" in display\n   218→    assert \"old code here\" not in display\n   219→    assert \"new code here\" not in display\n   220→\n   221→\n   222→def test_assistant_tool_use_write():\n   223→    \"\"\"Write tool displays file_path only, not content.\"\"\"\n   224→    event = {\n   225→        \"type\": \"assistant\",\n   226→        \"message\": {\n   227→            \"id\": \"msg_1\",\n   228→            \"content\": [\n   229→                {\n   230→                    \"type\": \"tool_use\",\n   231→                    \"id\": \"toolu_write\",\n   232→                    \"name\": \"Write\",\n   233→                    \"input\": {\n   234→                        \"file_path\": \"/src/new_file.py\",\n   235→                        \"content\": \"print('hello world')\",\n   236→                    },\n   237→                },\n   238→            ],\n   239→        },\n   240→    }\n   241→    display, _ = parse_stream_event(json.dumps(event))\n   242→    assert \"Write\" in display\n   243→    assert \"/src/new_file.py\" in display\n   244→    assert \"print\" not in display\n   245→\n   246→\n   247→def test_assistant_tool_use_glob():\n   248→    \"\"\"Glob tool displays the pattern.\"\"\"\n   249→    event = {\n   250→        \"type\": \"assistant\",\n   251→        \"message\": {\n   252→            \"id\": \"msg_1\",\n   253→            \"content\": [\n   254→                {\n   255→                    \"type\": \"tool_use\",\n   256→                    \"id\": \"toolu_glob\",\n   257→                    \"name\": \"Glob\",\n   258→                    \"input\": {\"pattern\": \"**/*.py\"},\n   259→                },\n   260→            ],\n   261→        },\n   262→    }\n   263→    display, _ = parse_stream_event(json.dumps(event))\n   264→    assert \"Glob\" in display\n   265→    assert \"**/*.py\" in display\n   266→\n   267→\n   268→def test_assistant_tool_use_notebookedit_fallback():\n   269→    \"\"\"NotebookEdit has no special handler; falls through to generic fallback.\"\"\"\n   270→    event = {\n   271→        \"type\": \"assistant\",\n   272→        \"message\": {\n   273→            \"id\": \"msg_1\",\n   274→            \"content\": [\n   275→                {\n   276→                    \"type\": \"tool_use\",\n   277→                    \"id\": \"toolu_nb\",\n   278→                    \"name\": \"NotebookEdit\",\n   279→                    \"input\": {\"notebook_path\": \"/nb.ipynb\", \"cell_index\": 3},\n   280→                },\n   281→            ],\n   282→        },\n   283→    }\n   284→    display, _ = parse_stream_event(json.dumps(event))\n   285→    assert \"NotebookEdit\" in display\n   286→\n   287→\n   288→def test_assistant_tool_use_unknown_tool_fallback():\n   289→    \"\"\"Unknown tool names use the generic str(input)[:120] fallback.\"\"\"\n   290→    event = {\n   291→        \"type\": \"assistant\",\n   292→        \"message\": {\n   293→            \"id\": \"msg_1\",\n   294→            \"content\": [\n   295→                {\n   296→                    \"type\": \"tool_use\",\n   297→                    \"id\": \"toolu_unk\",\n   298→                    \"name\": \"SomeUnknownTool\",\n   299→                    \"input\": {\"foo\": \"bar\"},\n   300→                },\n   301→            ],\n   302→        },\n   303→    }\n   304→    display, _ = parse_stream_event(json.dumps(event))\n   305→    assert \"SomeUnknownTool\" in display\n   306→    assert \"foo\" in display\n   307→\n   308→\n   309→def test_assistant_task_tool_without_subagent_type():\n   310→    \"\"\"Task tool with only description and no subagent_type.\"\"\"\n   311→    event = {\n   312→        \"type\": \"assistant\",\n   313→        \"message\": {\n   314→            \"id\": \"msg_1\",\n   315→            \"content\": [\n   316→                {\n   317→                    \"type\": \"tool_use\",\n   318→                    \"id\": \"toolu_task2\",\n   319→                    \"name\": \"Task\",\n   320→                    \"input\": {\"description\": \"Search for patterns\"},\n   321→                },\n   322→            ],\n   323→        },\n   324→    }\n   325→    display, _ = parse_stream_event(json.dumps(event))\n   326→    assert \"Task\" in display\n   327→    assert \"Search for patterns\" in display\n   328→    # Should NOT have a leading \": \" from empty agent type\n   329→    assert \"→ Task: Search for patterns\" in display\n   330→\n   331→\n   332→def test_assistant_empty_content_list():\n   333→    \"\"\"Assistant event with empty content list produces empty display.\"\"\"\n   334→    event = {\n   335→        \"type\": \"assistant\",\n   336→        \"message\": {\"id\": \"msg_1\", \"content\": []},\n   337→    }\n   338→    display, result = parse_stream_event(json.dumps(event))\n   339→    assert display == \"\"\n   340→    assert result is None\n   341→\n   342→\n   343→def test_assistant_content_non_dict_blocks_skipped():\n   344→    \"\"\"Non-dict items in content are skipped; only valid blocks are processed.\"\"\"\n   345→    event = {\n   346→        \"type\": \"assistant\",\n   347→        \"message\": {\n   348→            \"id\": \"msg_1\",\n   349→            \"content\": [42, \"string\", None, {\"type\": \"text\", \"text\": \"real\"}],\n   350→        },\n   351→    }\n   352→    display, _ = parse_stream_event(json.dumps(event))\n   353→    assert display == \"real\"\n   354→\n   355→\n   356→def test_result_event_non_string_result():\n   357→    \"\"\"Result event with non-string result returns the value as-is.\"\"\"\n   358→    event = {\"type\": \"result\", \"result\": {\"key\": \"value\"}}\n   359→    display, result = parse_stream_event(json.dumps(event))\n   360→    assert display == \"\"\n   361→    assert result == {\"key\": \"value\"}\n   362→\n   363→\n   364→# ===========================================================================\n   365→# _summarize_input — direct unit tests\n   366→# ===========================================================================\n   367→\n   368→\n   369→def test_summarize_input_bash_truncation():\n   370→    \"\"\"Bash command longer than 120 chars is truncated to 120.\"\"\"\n   371→    long_cmd = \"x\" * 200\n   372→    result = _summarize_input(\"Bash\", {\"command\": long_cmd})\n   373→    assert len(result) == 120\n   374→    assert result == long_cmd[:120]\n   375→\n   376→\n   377→def test_summarize_input_generic_fallback_truncation():\n   378→    \"\"\"Generic fallback with input > 120 chars adds '...' suffix.\"\"\"\n   379→    long_val = \"a\" * 200\n   380→    result = _summarize_input(\"UnknownTool\", {\"data\": long_val})\n   381→    assert result.endswith(\"...\")\n   382→    assert len(result) == 123  # 120 + \"...\"\n   383→\n   384→\n   385→def test_summarize_input_generic_fallback_no_truncation():\n   386→    \"\"\"Generic fallback with short input does not add '...' suffix.\"\"\"\n   387→    result = _summarize_input(\"UnknownTool\", {\"x\": 1})\n   388→    assert not result.endswith(\"...\")\n   389→\n   390→\n   391→def test_summarize_input_task_truncation():\n   392→    \"\"\"Task description longer than 120 chars is truncated.\"\"\"\n   393→    long_desc = \"d\" * 200\n   394→    result = _summarize_input(\"Task\", {\"description\": long_desc})\n   395→    assert len(result) == 120\n   396→\n   397→\n   398→def test_summarize_input_task_with_agent_truncation():\n   399→    \"\"\"Task with agent and long description is truncated to 120 total.\"\"\"\n   400→    long_desc = \"d\" * 200\n   401→    result = _summarize_input(\n   402→        \"Task\", {\"description\": long_desc, \"subagent_type\": \"Explore\"}\n   403→    )\n   404→    assert len(result) == 120\n   405→    assert result.startswith(\"Explore: \")\n   406→\n   407→\n   408→def test_summarize_input_edit_shows_only_file_path():\n   409→    \"\"\"Edit summary shows only file_path, not old/new text.\"\"\"\n   410→    result = _summarize_input(\n   411→        \"Edit\",\n   412→        {\n   413→            \"file_path\": \"/src/foo.py\",\n   414→            \"old_text\": \"old stuff\",\n   415→            \"new_text\": \"new stuff\",\n   416→        },\n   417→    )\n   418→    assert result == \"/src/foo.py\"\n   419→\n   420→\n   421→def test_summarize_input_write_shows_only_file_path():\n   422→    \"\"\"Write summary shows only file_path, not content.\"\"\"\n   423→    result = _summarize_input(\n   424→        \"Write\",\n   425→        {\n   426→            \"file_path\": \"/src/bar.py\",\n   427→            \"content\": \"lots of code\",\n   428→        },\n   429→    )\n   430→    assert result == \"/src/bar.py\"\n   431→\n   432→\n   433→def test_summarize_input_glob_shows_pattern():\n   434→    \"\"\"Glob summary shows the pattern.\"\"\"\n   435→    result = _summarize_input(\"Glob\", {\"pattern\": \"**/*.ts\"})\n   436→    assert result == \"**/*.ts\"\n   437→\n   438→\n   439→# ===========================================================================\n   440→# StreamParser (stateful) — delta tracking\n   441→# ===========================================================================\n   442→\n   443→\n   444→class TestStreamParserDelta:\n   445→    \"\"\"StreamParser deduplicates cumulative assistant message events.\"\"\"\n   446→\n   447→    def test_first_message_returns_text(self):\n   448→        parser = StreamParser()\n   449→        event = {\n   450→            \"type\": \"assistant\",\n   451→            \"message\": {\n   452→                \"id\": \"msg_1\",\n   453→                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n   454→            },\n   455→        }\n   456→        display, _ = parser.parse(json.dumps(event))\n   457→        assert display == \"Hello\"\n   458→\n   459→    def test_cumulative_message_returns_only_delta(self):\n   460→        parser = StreamParser()\n   461→        e1 = {\n   462→            \"type\": \"assistant\",\n   463→            \"message\": {\n   464→                \"id\": \"msg_1\",\n   465→                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n   466→            },\n   467→        }\n   468→        e2 = {\n   469→            \"type\": \"assistant\",\n   470→            \"message\": {\n   471→                \"id\": \"msg_1\",\n   472→                \"content\": [{\"type\": \"text\", \"text\": \"Hello world\"}],\n   473→            },\n   474→        }\n   475→        parser.parse(json.dumps(e1))\n   476→        display, _ = parser.parse(json.dumps(e2))\n   477→        assert display == \"world\"\n   478→\n   479→    def test_same_text_returns_empty(self):\n   480→        parser = StreamParser()\n   481→        event = {\n   482→            \"type\": \"assistant\",\n   483→            \"message\": {\n   484→                \"id\": \"msg_1\",\n   485→                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n   486→            },\n   487→        }\n   488→        parser.parse(json.dumps(event))\n   489→        display, _ = parser.parse(json.dumps(event))\n   490→        assert display == \"\"\n   491→\n   492→    def test_new_turn_resets_text_tracking(self):\n   493→        parser = StreamParser()\n   494→        e1 = {\n   495→            \"type\": \"assistant\",\n   496→            \"message\": {\n   497→                \"id\": \"msg_1\",\n   498→                \"content\": [{\"type\": \"text\", \"text\": \"Turn 1 text\"}],\n   499→            },\n   500→        }\n   501→        e2 = {\n   502→            \"type\": \"assistant\",\n   503→            \"message\": {\n   504→                \"id\": \"msg_2\",\n   505→                \"content\": [{\"type\": \"text\", \"text\": \"Turn 2 text\"}],\n   506→            },\n   507→        }\n   508→        parser.parse(json.dumps(e1))\n   509→        display, _ = parser.parse(json.dumps(e2))\n   510→        assert display == \"Turn 2 text\"\n   511→\n   512→    def test_tool_use_shown_once(self):\n   513→        parser = StreamParser()\n   514→        event = {\n   515→            \"type\": \"assistant\",\n   516→            \"message\": {\n   517→                \"id\": \"msg_1\",\n   518→                \"content\": [\n   519→                    {\n   520→                        \"type\": \"tool_use\",\n   521→                        \"id\": \"toolu_1\",\n   522→                        \"name\": \"Read\",\n   523→                        \"input\": {\"file_path\": \"/a.py\"},\n   524→                    },\n   525→                ],\n   526→            },\n   527→        }\n   528→        d1, _ = parser.parse(json.dumps(event))\n   529→        d2, _ = parser.parse(json.dumps(event))\n   530→        assert \"Read\" in d1\n   531→        assert d2 == \"\"  # already seen this tool_id\n   532→\n   533→    def test_cumulative_message_with_new_tool(self):\n   534→        \"\"\"Second snapshot adds a tool_use — only the tool is new.\"\"\"\n   535→        parser = StreamParser()\n   536→        e1 = {\n   537→            \"type\": \"assistant\",\n   538→            \"message\": {\n   539→                \"id\": \"msg_1\",\n   540→                \"content\": [{\"type\": \"text\", \"text\": \"Let me look\"}],\n   541→            },\n   542→        }\n   543→        e2 = {\n   544→            \"type\": \"assistant\",\n   545→            \"message\": {\n   546→                \"id\": \"msg_1\",\n   547→                \"content\": [\n   548→                    {\"type\": \"text\", \"text\": \"Let me look\"},\n   549→                    {\n   550→                        \"type\": \"tool_use\",\n   551→                        \"id\": \"toolu_1\",\n   552→                        \"name\": \"Glob\",\n   553→                        \"input\": {\"pattern\": \"**/*.py\"},\n   554→                    },\n   555→                ],\n   556→            },\n   557→        }\n   558→        parser.parse(json.dumps(e1))\n   559→        display, _ = parser.parse(json.dumps(e2))\n   560→        assert \"Glob\" in display\n   561→        assert \"Let me look\" not in display  # text unchanged\n   562→\n   563→    def test_result_event_still_captured(self):\n   564→        parser = StreamParser()\n   565→        event = {\"type\": \"result\", \"result\": \"Final output\"}\n   566→        display, result = parser.parse(json.dumps(event))\n   567→        assert display == \"\"\n   568→        assert result == \"Final output\"\n   569→\n   570→    def test_plain_text_passes_through(self):\n   571→        parser = StreamParser()\n   572→        display, result = parser.parse(\"not json\")\n   573→        assert display == \"not json\"\n   574→        assert result is None\n   575→\n   576→    def test_user_tool_result_shown(self):\n   577→        parser = StreamParser()\n   578→        event = {\n   579→            \"type\": \"user\",\n   580→            \"message\": {\n   581→                \"content\": [\n   582→                    {\n   583→                        \"type\": \"tool_result\",\n   584→                        \"tool_use_id\": \"toolu_1\",\n   585→                        \"content\": \"File contents here...\",\n   586→                    },\n   587→                ],\n   588→            },\n   589→        }\n   590→        display, _ = parser.parse(json.dumps(event))\n   591→        assert \"File contents here\" in display\n   592→\n   593→    def test_user_message_multiple_tool_results(self):\n   594→        \"\"\"Only the first tool_result's preview appears (early return).\"\"\"\n   595→        parser = StreamParser()\n   596→        event = {\n   597→            \"type\": \"user\",\n   598→            \"message\": {\n   599→                \"content\": [\n   600→                    {\n   601→                        \"type\": \"tool_result\",\n   602→                        \"tool_use_id\": \"toolu_1\",\n   603→                        \"content\": \"First result\",\n   604→                    },\n   605→                    {\n   606→                        \"type\": \"tool_result\",\n   607→                        \"tool_use_id\": \"toolu_2\",\n   608→                        \"content\": \"Second result\",\n   609→                    },\n   610→                ],\n   611→            },\n   612→        }\n   613→        display, _ = parser.parse(json.dumps(event))\n   614→        assert \"First result\" in display\n   615→        assert \"Second result\" not in display\n   616→\n   617→    def test_user_message_non_tool_result_content(self):\n   618→        \"\"\"User event with only text content (no tool_result) returns empty.\"\"\"\n   619→        parser = StreamParser()\n   620→        event = {\n   621→            \"type\": \"user\",\n   622→            \"message\": {\n   623→                \"content\": [\n   624→                    {\"type\": \"text\", \"text\": \"Some user text\"},\n   625→                ],\n   626→            },\n   627→        }\n   628→        display, _ = parser.parse(json.dumps(event))\n   629→        assert display == \"\"\n   630→\n   631→    def test_user_message_empty_content(self):\n   632→        \"\"\"User event with empty content list returns empty.\"\"\"\n   633→        parser = StreamParser()\n   634→        event = {\n   635→            \"type\": \"user\",\n   636→            \"message\": {\"content\": []},\n   637→        }\n   638→        display, _ = parser.parse(json.dumps(event))\n   639→        assert display == \"\"\n   640→\n   641→    def test_user_tool_result_long_content_truncated(self):\n   642→        \"\"\"User tool_result content > 80 chars is truncated with ellipsis.\"\"\"\n   643→        parser = StreamParser()\n   644→        long_content = \"x\" * 100\n   645→        event = {\n   646→            \"type\": \"user\",\n   647→            \"message\": {\n   648→                \"content\": [\n   649→                    {\n   650→                        \"type\": \"tool_result\",\n   651→                        \"tool_use_id\": \"toolu_1\",\n   652→                        \"content\": long_content,\n   653→                    },\n   654→                ],\n   655→            },\n   656→        }\n   657→        display, _ = parser.parse(json.dumps(event))\n   658→        assert \"…\" in display\n   659→        # The preview part (after \"    ← \") should be 80 chars + ellipsis\n   660→        preview = display.replace(\"    ← \", \"\")\n   661→        assert len(preview) == 81  # 80 chars + \"…\"\n   662→"}]},"parent_tool_use_id":null,"session_id":"95e5a686-e325-4661-b11b-31c542c127c9","uuid":"929c5ce2-31f2-4efd-b2e3-9d2a57c7da27","tool_use_result":{"type":"text","file":{"filePath":"/Users/travisf/Documents/projects/hyrda-worktrees/issue-36/tests/test_stream_parser.py","content":"\"\"\"Tests for dx/hydra/stream_parser.py.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).parent.parent))\n\nfrom stream_parser import StreamParser, _summarize_input, parse_stream_event\n\n# ===========================================================================\n# Stateless parse_stream_event\n# ===========================================================================\n\n\ndef test_plain_text_passes_through():\n    display, result = parse_stream_event(\"Hello world\")\n    assert display == \"Hello world\"\n    assert result is None\n\n\ndef test_empty_string():\n    display, result = parse_stream_event(\"\")\n    assert display == \"\"\n    assert result is None\n\n\ndef test_invalid_json_passes_through():\n    display, result = parse_stream_event(\"{not valid json\")\n    assert display == \"{not valid json\"\n    assert result is None\n\n\ndef test_assistant_text_content():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [{\"type\": \"text\", \"text\": \"Let me explore the codebase.\"}],\n        },\n    }\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"Let me explore the codebase.\"\n    assert result is None\n\n\ndef test_assistant_whitespace_only_text():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\"id\": \"msg_1\", \"content\": [{\"type\": \"text\", \"text\": \"   \\n\\n\"}]},\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert display.strip() == \"\"\n\n\ndef test_assistant_tool_use_in_content():\n    \"\"\"Tool use blocks in message.content are displayed.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_1\",\n                    \"name\": \"Read\",\n                    \"input\": {\"file_path\": \"/src/models.py\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Read\" in display\n    assert \"/src/models.py\" in display\n\n\ndef test_assistant_tool_use_grep():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_2\",\n                    \"name\": \"Grep\",\n                    \"input\": {\"pattern\": \"class Foo\", \"path\": \"/src\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Grep\" in display\n    assert \"class Foo\" in display\n\n\ndef test_assistant_tool_use_bash():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_3\",\n                    \"name\": \"Bash\",\n                    \"input\": {\"command\": \"make test\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Bash\" in display\n    assert \"make test\" in display\n\n\ndef test_assistant_mixed_text_and_tool():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\"type\": \"text\", \"text\": \"Looking at the file.\"},\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_4\",\n                    \"name\": \"Read\",\n                    \"input\": {\"file_path\": \"/a.py\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Looking at the file.\" in display\n    assert \"Read\" in display\n\n\ndef test_assistant_task_tool_shows_agent_type():\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_5\",\n                    \"name\": \"Task\",\n                    \"input\": {\n                        \"description\": \"Explore code\",\n                        \"subagent_type\": \"Explore\",\n                    },\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Task\" in display\n    assert \"Explore\" in display\n\n\ndef test_result_event():\n    event = {\n        \"type\": \"result\",\n        \"subtype\": \"success\",\n        \"result\": \"PLAN_START\\nStep 1\\nPLAN_END\\nSUMMARY: done\",\n    }\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result == \"PLAN_START\\nStep 1\\nPLAN_END\\nSUMMARY: done\"\n\n\ndef test_result_event_empty():\n    event = {\"type\": \"result\", \"result\": \"\"}\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result == \"\"\n\n\ndef test_system_event_skipped():\n    event = {\"type\": \"system\", \"subtype\": \"init\", \"session_id\": \"abc\"}\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result is None\n\n\ndef test_unknown_event_skipped():\n    event = {\"type\": \"something_else\", \"data\": 123}\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result is None\n\n\ndef test_assistant_tool_use_edit():\n    \"\"\"Edit tool displays file_path only, not old/new text.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_edit\",\n                    \"name\": \"Edit\",\n                    \"input\": {\n                        \"file_path\": \"/src/models.py\",\n                        \"old_text\": \"old code here\",\n                        \"new_text\": \"new code here\",\n                    },\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Edit\" in display\n    assert \"/src/models.py\" in display\n    assert \"old code here\" not in display\n    assert \"new code here\" not in display\n\n\ndef test_assistant_tool_use_write():\n    \"\"\"Write tool displays file_path only, not content.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_write\",\n                    \"name\": \"Write\",\n                    \"input\": {\n                        \"file_path\": \"/src/new_file.py\",\n                        \"content\": \"print('hello world')\",\n                    },\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Write\" in display\n    assert \"/src/new_file.py\" in display\n    assert \"print\" not in display\n\n\ndef test_assistant_tool_use_glob():\n    \"\"\"Glob tool displays the pattern.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_glob\",\n                    \"name\": \"Glob\",\n                    \"input\": {\"pattern\": \"**/*.py\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Glob\" in display\n    assert \"**/*.py\" in display\n\n\ndef test_assistant_tool_use_notebookedit_fallback():\n    \"\"\"NotebookEdit has no special handler; falls through to generic fallback.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_nb\",\n                    \"name\": \"NotebookEdit\",\n                    \"input\": {\"notebook_path\": \"/nb.ipynb\", \"cell_index\": 3},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"NotebookEdit\" in display\n\n\ndef test_assistant_tool_use_unknown_tool_fallback():\n    \"\"\"Unknown tool names use the generic str(input)[:120] fallback.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_unk\",\n                    \"name\": \"SomeUnknownTool\",\n                    \"input\": {\"foo\": \"bar\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"SomeUnknownTool\" in display\n    assert \"foo\" in display\n\n\ndef test_assistant_task_tool_without_subagent_type():\n    \"\"\"Task tool with only description and no subagent_type.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [\n                {\n                    \"type\": \"tool_use\",\n                    \"id\": \"toolu_task2\",\n                    \"name\": \"Task\",\n                    \"input\": {\"description\": \"Search for patterns\"},\n                },\n            ],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert \"Task\" in display\n    assert \"Search for patterns\" in display\n    # Should NOT have a leading \": \" from empty agent type\n    assert \"→ Task: Search for patterns\" in display\n\n\ndef test_assistant_empty_content_list():\n    \"\"\"Assistant event with empty content list produces empty display.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\"id\": \"msg_1\", \"content\": []},\n    }\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result is None\n\n\ndef test_assistant_content_non_dict_blocks_skipped():\n    \"\"\"Non-dict items in content are skipped; only valid blocks are processed.\"\"\"\n    event = {\n        \"type\": \"assistant\",\n        \"message\": {\n            \"id\": \"msg_1\",\n            \"content\": [42, \"string\", None, {\"type\": \"text\", \"text\": \"real\"}],\n        },\n    }\n    display, _ = parse_stream_event(json.dumps(event))\n    assert display == \"real\"\n\n\ndef test_result_event_non_string_result():\n    \"\"\"Result event with non-string result returns the value as-is.\"\"\"\n    event = {\"type\": \"result\", \"result\": {\"key\": \"value\"}}\n    display, result = parse_stream_event(json.dumps(event))\n    assert display == \"\"\n    assert result == {\"key\": \"value\"}\n\n\n# ===========================================================================\n# _summarize_input — direct unit tests\n# ===========================================================================\n\n\ndef test_summarize_input_bash_truncation():\n    \"\"\"Bash command longer than 120 chars is truncated to 120.\"\"\"\n    long_cmd = \"x\" * 200\n    result = _summarize_input(\"Bash\", {\"command\": long_cmd})\n    assert len(result) == 120\n    assert result == long_cmd[:120]\n\n\ndef test_summarize_input_generic_fallback_truncation():\n    \"\"\"Generic fallback with input > 120 chars adds '...' suffix.\"\"\"\n    long_val = \"a\" * 200\n    result = _summarize_input(\"UnknownTool\", {\"data\": long_val})\n    assert result.endswith(\"...\")\n    assert len(result) == 123  # 120 + \"...\"\n\n\ndef test_summarize_input_generic_fallback_no_truncation():\n    \"\"\"Generic fallback with short input does not add '...' suffix.\"\"\"\n    result = _summarize_input(\"UnknownTool\", {\"x\": 1})\n    assert not result.endswith(\"...\")\n\n\ndef test_summarize_input_task_truncation():\n    \"\"\"Task description longer than 120 chars is truncated.\"\"\"\n    long_desc = \"d\" * 200\n    result = _summarize_input(\"Task\", {\"description\": long_desc})\n    assert len(result) == 120\n\n\ndef test_summarize_input_task_with_agent_truncation():\n    \"\"\"Task with agent and long description is truncated to 120 total.\"\"\"\n    long_desc = \"d\" * 200\n    result = _summarize_input(\n        \"Task\", {\"description\": long_desc, \"subagent_type\": \"Explore\"}\n    )\n    assert len(result) == 120\n    assert result.startswith(\"Explore: \")\n\n\ndef test_summarize_input_edit_shows_only_file_path():\n    \"\"\"Edit summary shows only file_path, not old/new text.\"\"\"\n    result = _summarize_input(\n        \"Edit\",\n        {\n            \"file_path\": \"/src/foo.py\",\n            \"old_text\": \"old stuff\",\n            \"new_text\": \"new stuff\",\n        },\n    )\n    assert result == \"/src/foo.py\"\n\n\ndef test_summarize_input_write_shows_only_file_path():\n    \"\"\"Write summary shows only file_path, not content.\"\"\"\n    result = _summarize_input(\n        \"Write\",\n        {\n            \"file_path\": \"/src/bar.py\",\n            \"content\": \"lots of code\",\n        },\n    )\n    assert result == \"/src/bar.py\"\n\n\ndef test_summarize_input_glob_shows_pattern():\n    \"\"\"Glob summary shows the pattern.\"\"\"\n    result = _summarize_input(\"Glob\", {\"pattern\": \"**/*.ts\"})\n    assert result == \"**/*.ts\"\n\n\n# ===========================================================================\n# StreamParser (stateful) — delta tracking\n# ===========================================================================\n\n\nclass TestStreamParserDelta:\n    \"\"\"StreamParser deduplicates cumulative assistant message events.\"\"\"\n\n    def test_first_message_returns_text(self):\n        parser = StreamParser()\n        event = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n            },\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert display == \"Hello\"\n\n    def test_cumulative_message_returns_only_delta(self):\n        parser = StreamParser()\n        e1 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n            },\n        }\n        e2 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Hello world\"}],\n            },\n        }\n        parser.parse(json.dumps(e1))\n        display, _ = parser.parse(json.dumps(e2))\n        assert display == \"world\"\n\n    def test_same_text_returns_empty(self):\n        parser = StreamParser()\n        event = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Hello\"}],\n            },\n        }\n        parser.parse(json.dumps(event))\n        display, _ = parser.parse(json.dumps(event))\n        assert display == \"\"\n\n    def test_new_turn_resets_text_tracking(self):\n        parser = StreamParser()\n        e1 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Turn 1 text\"}],\n            },\n        }\n        e2 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_2\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Turn 2 text\"}],\n            },\n        }\n        parser.parse(json.dumps(e1))\n        display, _ = parser.parse(json.dumps(e2))\n        assert display == \"Turn 2 text\"\n\n    def test_tool_use_shown_once(self):\n        parser = StreamParser()\n        event = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [\n                    {\n                        \"type\": \"tool_use\",\n                        \"id\": \"toolu_1\",\n                        \"name\": \"Read\",\n                        \"input\": {\"file_path\": \"/a.py\"},\n                    },\n                ],\n            },\n        }\n        d1, _ = parser.parse(json.dumps(event))\n        d2, _ = parser.parse(json.dumps(event))\n        assert \"Read\" in d1\n        assert d2 == \"\"  # already seen this tool_id\n\n    def test_cumulative_message_with_new_tool(self):\n        \"\"\"Second snapshot adds a tool_use — only the tool is new.\"\"\"\n        parser = StreamParser()\n        e1 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [{\"type\": \"text\", \"text\": \"Let me look\"}],\n            },\n        }\n        e2 = {\n            \"type\": \"assistant\",\n            \"message\": {\n                \"id\": \"msg_1\",\n                \"content\": [\n                    {\"type\": \"text\", \"text\": \"Let me look\"},\n                    {\n                        \"type\": \"tool_use\",\n                        \"id\": \"toolu_1\",\n                        \"name\": \"Glob\",\n                        \"input\": {\"pattern\": \"**/*.py\"},\n                    },\n                ],\n            },\n        }\n        parser.parse(json.dumps(e1))\n        display, _ = parser.parse(json.dumps(e2))\n        assert \"Glob\" in display\n        assert \"Let me look\" not in display  # text unchanged\n\n    def test_result_event_still_captured(self):\n        parser = StreamParser()\n        event = {\"type\": \"result\", \"result\": \"Final output\"}\n        display, result = parser.parse(json.dumps(event))\n        assert display == \"\"\n        assert result == \"Final output\"\n\n    def test_plain_text_passes_through(self):\n        parser = StreamParser()\n        display, result = parser.parse(\"not json\")\n        assert display == \"not json\"\n        assert result is None\n\n    def test_user_tool_result_shown(self):\n        parser = StreamParser()\n        event = {\n            \"type\": \"user\",\n            \"message\": {\n                \"content\": [\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": \"toolu_1\",\n                        \"content\": \"File contents here...\",\n                    },\n                ],\n            },\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert \"File contents here\" in display\n\n    def test_user_message_multiple_tool_results(self):\n        \"\"\"Only the first tool_result's preview appears (early return).\"\"\"\n        parser = StreamParser()\n        event = {\n            \"type\": \"user\",\n            \"message\": {\n                \"content\": [\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": \"toolu_1\",\n                        \"content\": \"First result\",\n                    },\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": \"toolu_2\",\n                        \"content\": \"Second result\",\n                    },\n                ],\n            },\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert \"First result\" in display\n        assert \"Second result\" not in display\n\n    def test_user_message_non_tool_result_content(self):\n        \"\"\"User event with only text content (no tool_result) returns empty.\"\"\"\n        parser = StreamParser()\n        event = {\n            \"type\": \"user\",\n            \"message\": {\n                \"content\": [\n                    {\"type\": \"text\", \"text\": \"Some user text\"},\n                ],\n            },\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert display == \"\"\n\n    def test_user_message_empty_content(self):\n        \"\"\"User event with empty content list returns empty.\"\"\"\n        parser = StreamParser()\n        event = {\n            \"type\": \"user\",\n            \"message\": {\"content\": []},\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert display == \"\"\n\n    def test_user_tool_result_long_content_truncated(self):\n        \"\"\"User tool_result content > 80 chars is truncated with ellipsis.\"\"\"\n        parser = StreamParser()\n        long_content = \"x\" * 100\n        event = {\n            \"type\": \"user\",\n            \"message\": {\n                \"content\": [\n                    {\n                        \"type\": \"tool_result\",\n                        \"tool_use_id\": \"toolu_1\",\n                        \"content\": long_content,\n                    },\n                ],\n            },\n        }\n        display, _ = parser.parse(json.dumps(event))\n        assert \"…\" in display\n        # The preview part (after \"    ← \") should be 80 chars + ellipsis\n        preview = display.replace(\"    ← \", \"\")\n        assert len(preview) == 81  # 80 chars + \"…\"\n","numLines":662,"startLine":1,"totalLines":662}}}