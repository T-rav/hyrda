I'll explore the codebase to understand the current `EventBus` implementation and its usage patterns before creating a detailed plan.
  → Read: /Users/travisf/Documents/projects/hyrda/hydra/events.py
    ← File does not exist.
  → Read: /Users/travisf/Documents/projects/hyrda/hydra/dashboard.py
    ← <tool_use_error>Sibling tool call errored</tool_use_error>
  → Glob: **/events.py
  → Glob: **/dashboard.py
    ← /Users/travisf/Documents/projects/hyrda/events.py
    ← /Users/travisf/Documents/projects/hyrda/dashboard.py
  → Read: /Users/travisf/Documents/projects/hyrda/events.py
    ←      1→"""In-process event bus for broadcasting state changes to the dashboard."…
  → Read: /Users/travisf/Documents/projects/hyrda/dashboard.py
    ←      1→"""Live web dashboard for Hydra — FastAPI + WebSocket."""      2→      3→…
Now let me find all usages of `subscribe` and `unsubscribe` across the codebase, and check for existing tests.
  → Grep: /\.subscribe\(|\.unsubscribe\(/ in .
    ← dashboard.py:323:            queue = self._bus.subscribe() dashboard.py:342:    …
  → Glob: **/test*events*
  → Glob: **/tests/**
    ← /Users/travisf/Documents/projects/hyrda/tests/test_events.py /Users/travisf/Docu…
    ← /Users/travisf/Documents/projects/hyrda/tests/conftest.py /Users/travisf/Documen…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_events.py
    ←      1→"""Tests for dx/hydra/events.py - EventType, HydraEvent, and EventBus."""…
Let me check how tests use `subscribe()` without cleanup, and look at a few examples.
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_agent.py
    ←    645→    ) -> None:    646→        """run should publish WORKER_UPDATE with st…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_triage.py
    ←    105→    106→    @pytest.mark.asyncio    107→    async def test_evaluate_publi…
Good. I now have a complete picture. Let me verify one more thing — the imports already available in `events.py` to confirm `contextlib` is imported.

Now I have everything I need for a comprehensive plan. Here's my analysis:

**Issue Restatement**: `EventBus.subscribe()` returns a raw `asyncio.Queue` that must be manually cleaned up via `unsubscribe()`. The issue requests adding an async context manager `subscription()` method that automatically unsubscribes on exit, then updating the dashboard's WebSocket handler to use it.

PLAN_START

## Files to Modify

### 1. `events.py` — Add `subscription()` async context manager

**Changes:**
- Add `from collections.abc import AsyncIterator` import
- Add a new `subscription()` method to `EventBus` that is an `@contextlib.asynccontextmanager` returning an `AsyncIterator[asyncio.Queue[HydraEvent]]`
- The method creates a queue via `self.subscribe(max_queue)`, yields it, and calls `self.unsubscribe(queue)` in the `finally` block
- Keep existing `subscribe()` and `unsubscribe()` unchanged for backward compatibility

```python
@contextlib.asynccontextmanager
async def subscription(
    self, max_queue: int = 500
) -> AsyncIterator[asyncio.Queue[HydraEvent]]:
    """Async context manager that auto-unsubscribes on exit."""
    queue = self.subscribe(max_queue)
    try:
        yield queue
    finally:
        self.unsubscribe(queue)
```

### 2. `dashboard.py` — Use the new context manager in the WebSocket handler

**Changes at `websocket_endpoint` (line 316):**

Replace the manual subscribe/try/finally pattern:
```python
queue = self._bus.subscribe()
# ...
try:
    while True:
        event: HydraEvent = await queue.get()
        await ws.send_text(event.model_dump_json())
except WebSocketDisconnect:
    pass
except Exception:
    pass
finally:
    self._bus.unsubscribe(queue)
```

With the context manager:
```python
async with self._bus.subscription() as queue:
    # Send history on connect
    for event in history:
        try:
            await ws.send_text(event.model_dump_json())
        except Exception:
            return

    # Stream live events
    try:
        while True:
            event = await queue.get()
            await ws.send_text(event.model_dump_json())
    except WebSocketDisconnect:
        pass
    except Exception:
        pass
```

Note: the `history` snapshot (line 322) must remain **before** `subscription()` to preserve the existing race-condition-free ordering (events published between snapshot and subscribe are picked up by the live queue, never sent twice). Move the `async with` to start right after `history = self._bus.get_history()`.

### 3. `tests/test_events.py` — Add tests for the new context manager

Add a new test class `TestEventBusSubscription` with the following tests:

1. **`test_subscription_yields_queue_that_receives_events`** — Subscribe via context manager, publish an event, assert it arrives in the yielded queue.

2. **`test_subscription_unsubscribes_on_exit`** — Enter and exit the context manager, then publish an event and verify the queue does NOT receive it (confirming auto-unsubscribe). Also verify `bus._subscribers` is empty after exit.

3. **`test_subscription_unsubscribes_on_exception`** — Raise an exception inside the `async with` block, catch it outside, and verify the queue was still unsubscribed (cleanup happens even on error).

4. **`test_subscription_respects_max_queue`** — Pass a custom `max_queue` value and verify the yielded queue has the expected `maxsize`.

5. **`test_multiple_concurrent_subscriptions`** — Open two subscription context managers simultaneously, publish an event, verify both receive it, exit one, publish again, verify only the remaining one receives it.

## New Files

None.

## Implementation Steps

1. **Add the `subscription()` method to `EventBus` in `events.py`:**
   - Add `from collections.abc import AsyncIterator` to imports
   - Add the `@contextlib.asynccontextmanager` method after `unsubscribe()` (around line 77)

2. **Update `dashboard.py` WebSocket handler:**
   - Replace the manual subscribe + try/finally with `async with self._bus.subscription() as queue:`
   - Keep the history snapshot before entering the context manager
   - Remove the explicit `self._bus.unsubscribe(queue)` call in `finally`

3. **Write tests in `tests/test_events.py`:**
   - Add the `TestEventBusSubscription` class with the 5 tests described above
   - All tests should be `async def` (consistent with existing test style using `pytest-asyncio`)

4. **Run validation:**
   - `make lint` — verify formatting
   - `make test` — verify all tests pass
   - `make typecheck` — verify type annotations are correct

## Testing Strategy

- **Unit tests in `test_events.py`**: The 5 tests above directly test the context manager's behavior — normal flow, cleanup on exit, cleanup on exception, parameter forwarding, and concurrent usage.
- **No mocking needed**: `EventBus` is a pure in-memory class; tests can use it directly.
- **Existing tests must pass unchanged**: The raw `subscribe`/`unsubscribe` API is preserved, so all 395 lines of existing tests remain valid.
- **Dashboard test coverage**: The existing `test_dashboard.py` may have WebSocket tests that exercise the updated handler. Verify these still pass.

## Key Considerations

- **Backward compatibility**: `subscribe()` and `unsubscribe()` remain unchanged. The new `subscription()` is purely additive.
- **History snapshot ordering**: The `history = self._bus.get_history()` call in the WebSocket handler MUST stay before `subscription()` to avoid duplicate events. The existing comment explains this.
- **Exception safety**: The `@asynccontextmanager` with try/finally guarantees unsubscribe even if the caller raises, gets cancelled, etc. `unsubscribe()` already suppresses `ValueError` if the queue was already removed, so double-unsubscribe is safe.
- **`contextlib` is already imported** in `events.py` (line 6), so no new dependencies are needed beyond `AsyncIterator`.
- **Type annotation**: The return type should be `AsyncIterator[asyncio.Queue[HydraEvent]]` as required by `@asynccontextmanager`.

PLAN_END

SUMMARY: Add `EventBus.subscription()` async context manager that auto-unsubscribes on exit, update dashboard WebSocket handler to use it, and add 5 unit tests.