I'll start by exploring the relevant source code and existing tests to understand the current implementation and test coverage.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    220→                GitHubIssue(    221→                    number=raw["numbe…
  → Task: Explore: Find existing plan phase tests
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ← File content (28818 tokens) exceeds maximum allowed tokens (25000). Please use o…
  → Grep: /^class Test.*[Pp]lan|^def test.*plan|^class TestFetch/ in .
    ← <tool_use_error>InputValidationError: Grep failed due to the following issue: An…
  → Grep: /^class Test.*[Pp]lan|^def test.*plan|^class TestFetch/ in /Users/travisf/Documents/projects/hyrda/tests/test_orchestrat
    ← 247:class TestFetchReadyIssues: 1460:class TestFetchReviewablePrsSkipLogic: 1974…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1974→class TestPlanPhase:   1975→    """Tests for the PLAN phase in the orches…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←    247→class TestFetchReadyIssues:    248→    """Tests for the _fetch_ready_issu…
  → Grep: /^class TestFetchPlanIssues/ in /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ← No matches found
  → Grep: /fetch_plan|FetchPlan/ in /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ← 2029:        orch._fetch_plan_issues = AsyncMock(return_value=[issue])  # type: …
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1974→class TestPlanPhase:   1975→    """Tests for the PLAN phase in the orches…
Now let me read the `_plan_issues` method and the existing tests in detail.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    340→            if self._stop_event.is_set():    341→                logger.i…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←    247→class TestFetchReadyIssues:    248→    """Tests for the _fetch_ready_issu…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1974→class TestPlanPhase:   1975→    """Tests for the PLAN phase in the orches…
Let me now look at the `_fetch_ready_issues` method for comparison, the rest of `_plan_issues`, and how `_active_issues` is used.
  → Grep: /_fetch_ready_issues/ in /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ← 458:    async def _fetch_ready_issues(self) -> list[GitHubIssue]: 564:        is…
  → Grep: /_active_issues|_active_plan/ in /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ← 63:        self._active_issues: set[int] = set() 124:        self._active_issues…
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    435→                        issue.number,    436→                    )    437…
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    458→    async def _fetch_ready_issues(self) -> list[GitHubIssue]:    459→    …
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←     55→        self._reviewers = ReviewRunner(config, self._bus)     56→        …
Let me check the test helpers and conftest to understand the fixtures used.
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←      1→"""Tests for dx/hydra/orchestrator.py - HydraOrchestrator class."""      …
  → Grep: /def make_issue|RAW_ISSUE_JSON|max_planners/ in /Users/travisf/Documents/projects/hyrda/tests
    ← tests/test_dashboard.py:913:        assert body["config"]["max_planners"] == con…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←     50→def make_worker_result(     51→    issue_number: int = 42,     52→    bra…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/helpers.py
    ←      1→"""Shared test helpers for Hydra tests."""      2→      3→from __future__…
Now let me check the conftest.py for the `config` fixture and the `TestImplementBatch` class to understand the semaphore test pattern.
  → Grep: /def config|class TestImplementBatch|semaphore/ in /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ← 438:class TestImplementBatch: 485:    async def test_semaphore_limits_concurrenc…
  → Glob: tests/conftest.py
    ← /Users/travisf/Documents/projects/hyrda/tests/conftest.py
  → Read: /Users/travisf/Documents/projects/hyrda/tests/conftest.py
    ←      1→"""Shared fixtures and factories for Hydra tests."""      2→      3→from …
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←    438→class TestImplementBatch:    439→    """Tests for the _implement_batch co…
Now I have a thorough understanding of the codebase. Let me also check the `_fetch_plan_issues` behavior more carefully — specifically if it filters `_active_issues` like `_fetch_ready_issues` does.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    295→    async def _fetch_plan_issues(self) -> list[GitHubIssue]:    296→     …
Now I have a complete understanding of the code. Let me verify one more thing — whether `_fetch_plan_issues` actually filters active issues or not, and check the `NewIssueSpec` model for the default labels fallback path.
  → Grep: /class NewIssueSpec|class PlanResult/ in /Users/travisf/Documents/projects/hyrda/models.py
    ← 54:class NewIssueSpec(BaseModel): 55-    """Specification for a new issue discov…
I now have all the information needed. Here's my analysis and plan:

PLAN_START

## Issue Summary

Add missing edge-case tests for `_fetch_plan_issues` and `_plan_issues` in the `TestPlanPhase` class. Currently, `_fetch_plan_issues` has no direct unit tests (only exercised indirectly), and `_plan_issues` is missing tests for semaphore concurrency, failure-result propagation, and the default-labels fallback for new issues.

## Files to Modify

**`tests/test_orchestrator.py`** — Add a new `TestFetchPlanIssues` class and additional tests in `TestPlanPhase`.

## Implementation Steps

### 1. Add `TestFetchPlanIssues` class (new class, insert before `TestPlanPhase`)

Mirror the pattern from `TestFetchReadyIssues` (lines 247-431), but call `orch._fetch_plan_issues()` instead. Add these tests:

**a. `test_returns_parsed_issues_from_gh_output`**
- Mock `asyncio.create_subprocess_exec` to return valid JSON with a plan-labeled issue
- Call `_fetch_plan_issues()`, assert it returns the parsed issue

**b. `test_returns_empty_list_when_gh_fails`**
- Mock subprocess with `returncode=1`
- Assert returns `[]`

**c. `test_returns_empty_list_on_json_decode_error`**
- Mock subprocess returning invalid JSON (`b"not-json"`)
- Assert returns `[]`

**d. `test_returns_empty_list_when_gh_not_found`**
- Mock `asyncio.create_subprocess_exec` raising `FileNotFoundError`
- Assert returns `[]`

**e. `test_respects_batch_size_limit`**
- Create 9 issues in mock output, with `batch_size=3`
- Assert result length ≤ `config.batch_size`

**f. `test_dry_run_returns_empty_list`**
- Use dry-run config, assert returns `[]` and subprocess not called

**Note on active issue filtering:** `_fetch_plan_issues` does NOT filter `_active_issues` (unlike `_fetch_ready_issues` at line 472). This is an intentional difference — plan issues don't get added to `_active_issues`. We should NOT add a test for filtering that doesn't exist. Instead, file a discovery issue if this is a gap.

### 2. Add missing tests to `TestPlanPhase`

**a. `test_plan_issues_semaphore_limits_concurrency`**
- Mirror the pattern from `TestImplementBatch.test_semaphore_limits_concurrency` (line 485)
- Use a concurrency counter in a fake `_planners.plan` to track peak concurrent calls
- Create 5 issues, with `max_planners=1` (default from ConfigFactory)
- Assert `peak <= config.max_planners`

**b. `test_plan_issues_failure_returns_result_with_error`**
- Plan fails with `success=False, error="Agent crashed"`
- Assert the returned `PlanResult` list contains the failure result
- Assert `result.success is False` and `result.error == "Agent crashed"`

**c. `test_plan_issues_new_issues_use_default_planner_label_when_no_labels`**
- Create a `PlanResult` with `new_issues=[NewIssueSpec(title="X", body="Y")]` (empty labels list)
- Assert `create_issue` is called with `labels=[config.planner_label[0]]` (the fallback at line 423-426)

**d. `test_plan_issues_stop_event_cancels_remaining`**
- Set `_stop_event` after first plan call
- Assert remaining issues are not planned (tasks cancelled)

## Testing Strategy

All tests follow the existing patterns:
- Use `pytest.mark.asyncio`
- Use `AsyncMock` for subprocess and PRManager methods
- Use `make_issue()` helper for issue construction
- Use `PlanResult` directly for plan results
- Use `SubprocessMockBuilder` from conftest where appropriate
- Use `patch("asyncio.create_subprocess_exec", ...)` for `_fetch_plan_issues` tests
- Mock `_fetch_plan_issues` as `AsyncMock(return_value=...)` for `_plan_issues` tests

## Key Considerations

1. **`_fetch_plan_issues` has no `_active_issues` filtering** — Unlike `_fetch_ready_issues`, plan fetching doesn't skip active issues. This may be intentional (planning is fast/read-only) or a gap. The tests should reflect actual behavior, not assumed behavior.

2. **`_fetch_plan_issues` has two code paths** — When `planner_label` is empty, it fetches all open issues excluding downstream labels. When `planner_label` is set, it fetches by that label directly. The `TestFetchPlanIssues` tests should cover both paths (add a test with `planner_label=[]` config).

3. **Semaphore test needs `asyncio.sleep(0)`** — To actually test concurrency, the fake plan function must yield control with `await asyncio.sleep(0)` so tasks can overlap.

4. **RAW_ISSUE_JSON uses `"ready"` label** — For plan-phase tests, create a plan-specific JSON fixture with `"hydra-plan"` label for clarity, or reuse the existing one since `_fetch_plan_issues` doesn't filter by label content (that's done by `gh`).

PLAN_END

SUMMARY: Add ~10 new unit tests: a `TestFetchPlanIssues` class (6 tests mirroring `TestFetchReadyIssues`) and 4 new edge-case tests in `TestPlanPhase` (semaphore concurrency, failure result propagation, default labels fallback, stop-event cancellation).