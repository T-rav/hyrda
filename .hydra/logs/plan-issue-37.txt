I'll start by reading the relevant files mentioned in the issue to understand the current code structure.
  → Read: /Users/travisf/Documents/projects/hyrda/dashboard.py
    ←    255→                return JSONResponse(self._orchestrator.human_input_reques…
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    100→    def human_input_requests(self) -> dict[int, str]:    101→        """P…
Now let me see where the private method `_publish_status()` is called from the dashboard and the full stop endpoint.
  → Grep: /_publish_status/ in /Users/travisf/Documents/projects/hyrda
    ← dashboard.py:287:            await self._orchestrator._publish_status() orchestr…
  → Read: /Users/travisf/Documents/projects/hyrda/dashboard.py
    ←    279→            self._run_task = asyncio.create_task(orch.run())    280→     …
Now let me look at the full `run()` method to see how `_publish_status` is called at the end when stopping.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←    135→    async def run(self) -> None:    136→        """Run three independent,…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_dashboard.py
    ←     35→    run_status: str = "idle",     36→) -> MagicMock:     37→    """Return…
Let me also check the existing tests for the stop endpoint and the `stop()` method.
  → Grep: /stop_orchestrator|control/stop/ in /Users/travisf/Documents/projects/hyrda/tests
    ← tests/test_dashboard.py:786:# POST /api/control/stop tests/test_dashboard.py:791…
  → Grep: /def test.*stop|def test.*request_stop/ in /Users/travisf/Documents/projects/hyrda/tests
    ← tests/test_pr_manager.py:1159:async def test_wait_for_ci_respects_stop_event(con…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_dashboard.py
    ←    786→# POST /api/control/stop    787→# ---------------------------------------…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1695→    def test_request_stop_sets_stop_event(self, config: HydraConfig) -> N…
Now let me check the `stop()` method's current synchronous nature and understand whether making it async or adding a separate async method would be better.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←      1→"""Main orchestrator loop — plan, implement, review, cleanup, repeat.""" …
  → Grep: /\.stop\(\)|\.request_stop\(\)/ in /Users/travisf/Documents/projects/hyrda
    ← dashboard.py:286:            self._orchestrator.request_stop() cli.py:255:      …
Now let me check how `run_status` is computed and the `EventBus.publish` signature.
  → Grep: /run_status/ in /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ← 84:    def run_status(self) -> str: 131:                data={"status": self.run…
  → Read: /Users/travisf/Documents/projects/hyrda/events.py
    ←      1→"""In-process event bus for broadcasting state changes to the dashboard."…
Let me also see the `run_status` property to understand what status value it returns after `stop()` is called.
  → Read: /Users/travisf/Documents/projects/hyrda/orchestrator.py
    ←     80→        """Whether the orchestrator is currently executing."""     81→   …
Now I have a complete understanding. Let me check whether `stop()` is called from any synchronous contexts to understand the impact of making it async.
  → Grep: /orch\.stop\(\)|orchestrator\.stop\(\)|self\.stop\(\)/ in /Users/travisf/Documents/projects/hyrda
    ← tests/test_orchestrator.py:1709:            orch.stop()
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1695→    def test_request_stop_sets_stop_event(self, config: HydraConfig) -> N…
Now I understand the full picture. The key insight is:

1. `stop()` is currently synchronous — it sets the stop event and terminates runners.
2. `_publish_status()` is async and publishes the "stopping" status to subscribers.
3. The dashboard calls `stop()` then `_publish_status()` separately, which breaks encapsulation.
4. The `run()` method's `finally` block already calls `_publish_status()`, but that runs when the loops finish, not immediately when stop is requested.

The cleanest approach: make `stop()` an async method that publishes status after setting the stop event, and keep `request_stop` as the sync alias for callers that can't await.

Let me verify there aren't other callers that depend on `stop()` being synchronous.
  → Grep: /request_stop\(\)/ in /Users/travisf/Documents/projects/hyrda
    ← dashboard.py:286:            self._orchestrator.request_stop() tests/test_orches…
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1780→    async def test_stop_halts_loops(self, config: HydraConfig) -> None:  …
Now I have a complete picture. Let me verify one more thing — the test for `stop_event_terminates_all_loops` which is async and also calls stop.
  → Read: /Users/travisf/Documents/projects/hyrda/tests/test_orchestrator.py
    ←   1600→    async def test_stop_event_terminates_all_loops(self, config: HydraCon…
I now have complete understanding of all relevant code. Here is my plan:

PLAN_START

## Issue Summary

The dashboard's `stop_orchestrator` endpoint (dashboard.py:286-287) calls the private method `self._orchestrator._publish_status()` after `request_stop()`. This breaks encapsulation. The orchestrator should publish its own status when stopped, so external callers don't need to know about internal methods.

## Files to Modify

### 1. `orchestrator.py` — Make `stop()` async and have it publish status

**Current code** (lines 109-118):
```python
def stop(self) -> None:
    """Signal the orchestrator to stop and kill active subprocesses."""
    self._stop_event.set()
    logger.info("Stop requested — terminating active processes")
    self._planners.terminate()
    self._agents.terminate()
    self._reviewers.terminate()

# Alias for backward compatibility
request_stop = stop
```

**Change to**:
```python
async def stop(self) -> None:
    """Signal the orchestrator to stop and kill active subprocesses."""
    self._stop_event.set()
    logger.info("Stop requested — terminating active processes")
    self._planners.terminate()
    self._agents.terminate()
    self._reviewers.terminate()
    await self._publish_status()

# Alias for backward compatibility
request_stop = stop
```

**Why async**: `_publish_status()` is async (it calls `EventBus.publish` which pushes to async queues). Converting `stop()` to async is the only clean way to call it without fire-and-forget hacks. All current callers are in async contexts anyway.

**Status broadcast behavior**: After this change, calling `stop()` immediately broadcasts `run_status = "stopping"` (since `_running` is still `True` and `_stop_event` is set). Later, when `run()`'s `finally` block sets `_running = False` and calls `_publish_status()` again, it broadcasts `"idle"` or `"done"`. This is correct — the UI sees "stopping" → "idle"/"done".

### 2. `dashboard.py` — Remove private method access

**Current code** (lines 285-288):
```python
if not self._orchestrator or not self._orchestrator.running:
    return JSONResponse({"error": "not running"}, status_code=400)
self._orchestrator.request_stop()
await self._orchestrator._publish_status()
return JSONResponse({"status": "stopping"})
```

**Change to**:
```python
if not self._orchestrator or not self._orchestrator.running:
    return JSONResponse({"error": "not running"}, status_code=400)
await self._orchestrator.request_stop()
return JSONResponse({"status": "stopping"})
```

Remove line 287 (`await self._orchestrator._publish_status()`) and add `await` to the `request_stop()` call on line 286.

### 3. `tests/test_dashboard.py` — Remove `_publish_status` mock from helper

**Current code** (line 45):
```python
orch._publish_status = AsyncMock()
```

**Change**: Remove this line from `make_orchestrator_mock()`. The mock's `request_stop` (already a `MagicMock`) doesn't need a separate `_publish_status` mock since the dashboard no longer calls it directly. However, since `request_stop` is now async, update the mock:

```python
orch.request_stop = AsyncMock()
```

Also update `orch.stop` to `AsyncMock()` for consistency.

### 4. `tests/test_orchestrator.py` — Update tests for async `stop()`

**Tests that need updating:**

1. **`test_request_stop_sets_stop_event`** (line 1695) — Currently a sync test calling `orch.request_stop()`. Convert to async:
   ```python
   @pytest.mark.asyncio
   async def test_request_stop_sets_stop_event(self, config: HydraConfig) -> None:
       orch = HydraOrchestrator(config)
       assert not orch._stop_event.is_set()
       await orch.request_stop()
       assert orch._stop_event.is_set()
   ```

2. **`test_stop_terminates_all_runners`** (line 1701) — Currently a sync test calling `orch.stop()`. Convert to async and also mock `_publish_status`:
   ```python
   @pytest.mark.asyncio
   async def test_stop_terminates_all_runners(self, config: HydraConfig) -> None:
       """stop() should call terminate() on planners, agents, and reviewers."""
       orch = HydraOrchestrator(config)
       with (
           patch.object(orch._planners, "terminate") as mock_p,
           patch.object(orch._agents, "terminate") as mock_a,
           patch.object(orch._reviewers, "terminate") as mock_r,
       ):
           await orch.stop()

       mock_p.assert_called_once()
       mock_a.assert_called_once()
       mock_r.assert_called_once()
   ```

3. **`test_stop_halts_loops`** (line 1780) — Calls `orch.request_stop()` from inside an async function. Add `await`:
   ```python
   async def counting_implement():
       nonlocal call_count
       call_count += 1
       await orch.request_stop()
       return [make_worker_result(42)], [make_issue(42)]
   ```

4. **`test_stop_event_cleared_on_new_run`** (line 1802) — Calls `orch.request_stop()` both synchronously (line 1806) and from within async mock. Convert the sync call:
   ```python
   await orch.request_stop()
   ```

5. **`test_running_false_after_stop`** (line 1825) — Calls `orch.request_stop()` from inside async function. Add `await`:
   ```python
   async def stop_on_implement():
       await orch.request_stop()
       return [make_worker_result(42)], [make_issue(42)]
   ```

6. **`test_triage_stops_when_stop_event_set`** (line 1929) — Verify if it calls `request_stop()` or just sets `_stop_event` directly.

### 5. `tests/test_orchestrator.py` — Add new test for status publish on stop

Add a new test to verify that `stop()` publishes the status:

```python
@pytest.mark.asyncio
async def test_stop_publishes_status(self, config: HydraConfig) -> None:
    """stop() should publish ORCHESTRATOR_STATUS event."""
    orch = HydraOrchestrator(config)
    orch._running = True  # simulate running state
    await orch.stop()
    
    # Verify the bus received an ORCHESTRATOR_STATUS event with "stopping"
    history = orch._bus.get_history()
    status_events = [e for e in history if e.type == EventType.ORCHESTRATOR_STATUS]
    assert len(status_events) == 1
    assert status_events[0].data["status"] == "stopping"
```

## Implementation Steps

1. **Modify `orchestrator.py`**: Convert `stop()` from `def` to `async def`, add `await self._publish_status()` at the end.
2. **Modify `dashboard.py`**: Remove the `_publish_status()` call on line 287. Add `await` to the `request_stop()` call on line 286.
3. **Update `tests/test_dashboard.py`**: Remove `orch._publish_status = AsyncMock()` from `make_orchestrator_mock()`. Change `orch.request_stop = MagicMock()` and `orch.stop = MagicMock()` to `AsyncMock()`.
4. **Update `tests/test_orchestrator.py`**: Convert the sync tests to async, add `await` to all `stop()`/`request_stop()` calls, add new test for status publication.
5. **Run `make quality`** to verify all tests pass, linting is clean, and type checking succeeds.

## Testing Strategy

- **Existing tests**: All existing tests for `stop()`, `request_stop()`, and the `/api/control/stop` endpoint continue to work (with the async updates).
- **New test**: `test_stop_publishes_status` verifies the core behavior change — that `stop()` now publishes an `ORCHESTRATOR_STATUS` event.
- **Regression coverage**: The `test_stop_returns_stopping_when_running` dashboard test confirms the endpoint no longer needs `_publish_status` — the mock no longer sets it up, and the test still passes.

## Key Considerations

- **Double publish is harmless**: `stop()` publishes "stopping", then `run()`'s `finally` publishes "idle"/"done". These are distinct, correct statuses — the UI gets an immediate update followed by a final state.
- **No sync callers broken**: All callers of `stop()`/`request_stop()` are in async contexts (dashboard endpoints, async test functions, or async mock callbacks inside `run()`). The two sync tests just need the `@pytest.mark.asyncio` decorator added.
- **Alias still works**: `request_stop = stop` works the same for async methods — `request_stop` becomes an async method alias.

PLAN_END

SUMMARY: Convert `stop()` to async, have it call `_publish_status()` internally, remove the private method access from dashboard.py, and update tests accordingly.