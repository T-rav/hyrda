"""Pull request lifecycle management via the ``gh`` CLI."""

from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import os
import tempfile
from pathlib import Path
from typing import Any, Literal

from config import HydraFlowConfig
from events import EventBus, EventType, HydraFlowEvent
from models import GitHubIssue, HITLItem, PRInfo, PRListItem, ReviewVerdict
from prep import HYDRAFLOW_LABELS
from subprocess_util import run_subprocess, run_subprocess_with_retry

logger = logging.getLogger("hydraflow.pr_manager")


class SelfReviewError(RuntimeError):
    """Raised when a formal review fails due to the 'own pull request' restriction."""


class PRManager:
    """Pushes branches, creates PRs, merges, and manages labels."""

    _GITHUB_COMMENT_LIMIT = 65_536
    _HEADER_RESERVE = 50  # room for "*Part X/Y*\n\n" prefix

    # Re-export from prep module for backward compatibility
    _HYDRAFLOW_LABELS = HYDRAFLOW_LABELS

    def __init__(self, config: HydraFlowConfig, event_bus: EventBus) -> None:
        self._config = config
        self._bus = event_bus
        self._repo = config.repo
        self._max_retries = config.gh_max_retries

    async def _run_gh(self, *cmd: str, cwd: Path | None = None) -> str:
        """Run a gh/git command with retry logic."""
        return await run_subprocess_with_retry(
            *cmd,
            cwd=cwd or self._config.repo_root,
            gh_token=self._config.gh_token,
            max_retries=self._max_retries,
        )

    async def ensure_labels_exist(self) -> None:
        """Create all HydraFlow lifecycle labels in the repo if they don't exist.

        Delegates to :func:`prep.ensure_labels` which handles creation,
        reporting, and dry-run behaviour.
        """
        from prep import ensure_labels  # noqa: PLC0415

        result = await ensure_labels(self._config)
        logger.info(result.summary())

    async def push_branch(self, worktree_path: Path, branch: str) -> bool:
        """Push *branch* to origin from *worktree_path*.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would push branch %s", branch)
            return True

        try:
            await run_subprocess(
                "git",
                "push",
                "--no-verify",
                "-u",
                "origin",
                branch,
                cwd=worktree_path,
                gh_token=self._config.gh_token,
            )
            return True
        except RuntimeError as exc:
            logger.error("Push failed for %s: %s", branch, exc)
            return False

    async def create_pr(
        self,
        issue: GitHubIssue,
        branch: str,
        *,
        draft: bool = False,
    ) -> PRInfo:
        """Create a PR for *branch* linked to *issue*.

        Returns a :class:`PRInfo` with the PR number and URL.
        """
        title = f"Fixes #{issue.number}: {issue.title}"
        if len(title) > 70:
            title = title[:67] + "..."

        body = (
            f"## Summary\n\n"
            f"Closes #{issue.number}.\n\n"
            f"## Issue\n\n{issue.title}\n\n"
            f"## Test plan\n\n"
            f"- [ ] Unit tests pass (`make test`)\n"
            f"- [ ] Linting passes (`make lint`)\n"
            f"- [ ] Manual review of changes\n\n"
            f"---\n"
            f"Generated by HydraFlow"
        )

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would create %sPR for issue #%d",
                "draft " if draft else "",
                issue.number,
            )
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                url="",
                draft=draft,
            )

        cmd = [
            "gh",
            "pr",
            "create",
            "--repo",
            self._repo,
            "--head",
            branch,
            "--base",
            self._config.main_branch,
            "--title",
            title,
        ]
        if draft:
            cmd.append("--draft")

        try:
            output = await self._run_with_body_file(
                *cmd, body=body, cwd=self._config.repo_root
            )
            # gh pr create --json would be better, but the URL is in stdout
            pr_url = output.strip()

            # Get PR number from URL (e.g., https://github.com/org/repo/pull/123)
            pr_number = int(pr_url.rstrip("/").split("/")[-1])

            pr_info = PRInfo(
                number=pr_number,
                issue_number=issue.number,
                branch=branch,
                url=pr_url,
                draft=draft,
            )

            await self._bus.publish(
                HydraFlowEvent(
                    type=EventType.PR_CREATED,
                    data={
                        "pr": pr_number,
                        "issue": issue.number,
                        "branch": branch,
                        "draft": draft,
                        "url": pr_url,
                    },
                )
            )

            return pr_info

        except (RuntimeError, ValueError) as exc:
            logger.error("PR creation failed for issue #%d: %s", issue.number, exc)
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                draft=draft,
            )

    async def merge_pr(self, pr_number: int) -> bool:
        """Merge PR immediately via squash merge with branch deletion.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would merge PR #%d", pr_number)
            return True

        try:
            await run_subprocess(
                "gh",
                "pr",
                "merge",
                str(pr_number),
                "--repo",
                self._repo,
                "--squash",
                "--delete-branch",
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )

            await self._bus.publish(
                HydraFlowEvent(
                    type=EventType.MERGE_UPDATE,
                    data={"pr": pr_number, "status": "merged"},
                )
            )
            return True
        except RuntimeError as exc:
            logger.error("Merge failed for PR #%d: %s", pr_number, exc)
            return False

    async def _comment(
        self, target: Literal["issue", "pr"], number: int, body: str
    ) -> None:
        """Post a comment on a GitHub issue or PR."""
        if self._config.dry_run:
            logger.info("[dry-run] Would post comment on %s #%d", target, number)
            return
        chunk_limit = self._GITHUB_COMMENT_LIMIT - self._HEADER_RESERVE
        chunks = self._chunk_body(body, chunk_limit)
        for idx, chunk in enumerate(chunks):
            part = chunk
            if len(chunks) > 1:
                part = f"*Part {idx + 1}/{len(chunks)}*\n\n{chunk}"
            part = self._cap_body(part, self._GITHUB_COMMENT_LIMIT)
            try:
                await self._run_with_body_file(
                    "gh",
                    target,
                    "comment",
                    str(number),
                    "--repo",
                    self._repo,
                    body=part,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not post comment on %s #%d: %s",
                    target,
                    number,
                    exc,
                )

    async def post_comment(self, issue_number: int, body: str) -> None:
        """Post a comment on a GitHub issue."""
        await self._comment("issue", issue_number, body)

    async def post_pr_comment(self, pr_number: int, body: str) -> None:
        """Post a comment on a GitHub pull request."""
        await self._comment("pr", pr_number, body)

    async def submit_review(
        self, pr_number: int, verdict: ReviewVerdict, body: str
    ) -> bool:
        """Submit a formal GitHub PR review.

        *verdict* is a :class:`ReviewVerdict` enum member.
        Returns *True* on success.
        """
        flag_map = {
            ReviewVerdict.APPROVE: "--approve",
            ReviewVerdict.REQUEST_CHANGES: "--request-changes",
            ReviewVerdict.COMMENT: "--comment",
        }
        flag = flag_map[verdict]

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would submit %s review on PR #%d",
                verdict.value,
                pr_number,
            )
            return True

        body = self._cap_body(body, self._GITHUB_COMMENT_LIMIT)
        try:
            await self._run_with_body_file(
                "gh",
                "pr",
                "review",
                str(pr_number),
                "--repo",
                self._repo,
                flag,
                body=body,
                cwd=self._config.repo_root,
            )
            return True
        except RuntimeError as exc:
            err_msg = str(exc)
            err_lower = err_msg.lower()
            if (
                "can not request changes on your own pull request" in err_lower
                or "cannot approve your own pull request" in err_lower
            ):
                logger.info(
                    "Cannot submit %s review on own PR #%d — falling back to comment",
                    verdict.value,
                    pr_number,
                )
                raise SelfReviewError(err_msg) from exc
            logger.error(
                "Could not submit %s review on PR #%d: %s",
                verdict.value,
                pr_number,
                exc,
            )
            return False

    async def _add_labels(
        self, target: Literal["issue", "pr"], number: int, labels: list[str]
    ) -> None:
        """Add *labels* to a GitHub issue or PR."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await self._run_gh(
                    "gh",
                    target,
                    "edit",
                    str(number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to %s #%d: %s",
                    label,
                    target,
                    number,
                    exc,
                )

    async def add_labels(self, issue_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub issue."""
        await self._add_labels("issue", issue_number, labels)

    async def _remove_label(
        self, target: Literal["issue", "pr"], number: int, label: str
    ) -> None:
        """Remove *label* from a GitHub issue or PR."""
        if self._config.dry_run:
            return
        try:
            await self._run_gh(
                "gh",
                target,
                "edit",
                str(number),
                "--repo",
                self._repo,
                "--remove-label",
                label,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not remove label %r from %s #%d: %s",
                label,
                target,
                number,
                exc,
            )

    async def remove_label(self, issue_number: int, label: str) -> None:
        """Remove *label* from a GitHub issue."""
        await self._remove_label("issue", issue_number, label)

    async def close_issue(self, issue_number: int) -> None:
        """Close a GitHub issue."""
        if self._config.dry_run:
            return
        try:
            await self._run_gh(
                "gh",
                "issue",
                "close",
                str(issue_number),
                "--repo",
                self._repo,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not close issue #%d: %s",
                issue_number,
                exc,
            )

    async def update_issue_body(self, issue_number: int, body: str) -> None:
        """Update the body of a GitHub issue using ``--body-file``."""
        if self._config.dry_run:
            return
        fd, tmp_path = tempfile.mkstemp(suffix=".md", prefix="hydraflow-body-")
        try:
            with os.fdopen(fd, "w") as f:
                f.write(body)
            await self._run_gh(
                "gh",
                "issue",
                "edit",
                str(issue_number),
                "--repo",
                self._repo,
                "--body-file",
                tmp_path,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not update body for issue #%d: %s",
                issue_number,
                exc,
            )
        finally:
            Path(tmp_path).unlink(missing_ok=True)

    async def remove_pr_label(self, pr_number: int, label: str) -> None:
        """Remove *label* from a GitHub pull request."""
        await self._remove_label("pr", pr_number, label)

    async def add_pr_labels(self, pr_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub pull request."""
        await self._add_labels("pr", pr_number, labels)

    async def swap_pipeline_labels(
        self,
        issue_number: int,
        new_label: str,
        *,
        pr_number: int | None = None,
    ) -> None:
        """Atomically swap to *new_label*, removing all other pipeline labels.

        This prevents the dual-label bug where a crash between remove and add
        leaves an issue with conflicting pipeline labels (e.g. hydraflow-ready +
        hydraflow-hitl simultaneously).
        """
        all_labels = self._config.all_pipeline_labels
        for lbl in all_labels:
            if lbl != new_label:
                await self._remove_label("issue", issue_number, lbl)
                if pr_number is not None:
                    await self._remove_label("pr", pr_number, lbl)
        await self._add_labels("issue", issue_number, [new_label])
        if pr_number is not None:
            await self._add_labels("pr", pr_number, [new_label])

    async def create_issue(
        self,
        title: str,
        body: str,
        labels: list[str] | None = None,
    ) -> int:
        """Create a new GitHub issue. Returns the issue number (0 on failure)."""
        if self._config.dry_run:
            logger.info("[dry-run] Would create issue: %s", title)
            return 0

        cmd = [
            "gh",
            "issue",
            "create",
            "--repo",
            self._repo,
            "--title",
            title,
        ]
        for label in labels or []:
            cmd.extend(["--label", label])

        try:
            output = await self._run_with_body_file(
                *cmd, body=body, cwd=self._config.repo_root
            )
            # gh issue create prints the issue URL
            issue_number = int(output.strip().rstrip("/").split("/")[-1])

            await self._bus.publish(
                HydraFlowEvent(
                    type=EventType.ISSUE_CREATED,
                    data={
                        "number": issue_number,
                        "title": title,
                        "labels": labels or [],
                    },
                )
            )
            return issue_number
        except (RuntimeError, ValueError) as exc:
            logger.error("Issue creation failed for %r: %s", title, exc)
            return 0

    async def get_pr_diff(self, pr_number: int) -> str:
        """Fetch the diff for *pr_number*."""
        try:
            return await self._run_gh(
                "gh",
                "pr",
                "diff",
                str(pr_number),
                "--repo",
                self._repo,
            )
        except RuntimeError as exc:
            logger.error("Could not get diff for PR #%d: %s", pr_number, exc)
            return ""

    async def get_pr_diff_names(self, pr_number: int) -> list[str]:
        """Fetch the list of files changed in *pr_number*."""
        try:
            output = await self._run_gh(
                "gh",
                "pr",
                "diff",
                str(pr_number),
                "--repo",
                self._repo,
                "--name-only",
            )
            return [f.strip() for f in output.strip().splitlines() if f.strip()]
        except RuntimeError as exc:
            logger.error("Could not get diff file names for PR #%d: %s", pr_number, exc)
            return []

    async def get_pr_status(self, pr_number: int) -> dict[str, object]:
        """Fetch PR status as JSON."""
        try:
            raw = await self._run_gh(
                "gh",
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "number,state,mergeable,title,isDraft",
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.error("Could not get status for PR #%d: %s", pr_number, exc)
            return {}

    async def pull_main(self) -> bool:
        """Pull latest main into the local repo."""
        if self._config.dry_run:
            logger.info("[dry-run] Would pull main")
            return True
        try:
            await self._run_gh(
                "git",
                "pull",
                "origin",
                self._config.main_branch,
            )
            return True
        except RuntimeError as exc:
            logger.error("Pull main failed: %s", exc)
            return False

    # --- CI check methods ---

    async def get_pr_checks(self, pr_number: int) -> list[dict[str, str]]:
        """Fetch CI check results for *pr_number*.

        Returns a list of dicts with ``name`` and ``state`` keys.
        Returns an empty list on failure or in dry-run mode.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would fetch CI checks for PR #%d", pr_number)
            return []

        try:
            raw = await self._run_gh(
                "gh",
                "pr",
                "checks",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "name,state",
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.warning("Could not fetch CI checks for PR #%d: %s", pr_number, exc)
            return []

    _PASSING_STATES = frozenset({"SUCCESS", "NEUTRAL", "SKIPPED"})
    _PENDING_STATES = frozenset(
        {"PENDING", "QUEUED", "IN_PROGRESS", "REQUESTED", "WAITING"}
    )

    async def wait_for_ci(  # noqa: PLR0911
        self,
        pr_number: int,
        timeout: int,
        poll_interval: int,
        stop_event: asyncio.Event,
    ) -> tuple[bool, str]:
        """Poll CI checks until all complete or *timeout* seconds elapse.

        Returns ``(passed, summary_message)``.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would wait for CI on PR #%d", pr_number)
            return True, "Dry-run: CI skipped"

        elapsed = 0
        while elapsed < timeout:
            if stop_event.is_set():
                return False, "Stopped"

            checks = await self.get_pr_checks(pr_number)

            if not checks:
                return True, "No CI checks found"

            pending = [
                c for c in checks if c.get("state", "").upper() in self._PENDING_STATES
            ]
            if pending:
                await self._bus.publish(
                    HydraFlowEvent(
                        type=EventType.CI_CHECK,
                        data={
                            "pr": pr_number,
                            "status": "pending",
                            "pending": len(pending),
                            "total": len(checks),
                        },
                    )
                )
                try:
                    await asyncio.wait_for(stop_event.wait(), timeout=poll_interval)
                    # If we get here, stop_event was set
                    return False, "Stopped"
                except TimeoutError:
                    elapsed += poll_interval
                    continue

            # All checks completed — check states
            failed = [
                c["name"]
                for c in checks
                if c.get("state", "").upper() not in self._PASSING_STATES
            ]
            passed = not failed
            status = "passed" if passed else "failed"
            data: dict[str, object] = {"pr": pr_number, "status": status}
            if failed:
                data["failed"] = failed
            else:
                data["total"] = len(checks)

            await self._bus.publish(HydraFlowEvent(type=EventType.CI_CHECK, data=data))

            if passed:
                return True, f"All {len(checks)} checks passed"
            return False, f"Failed checks: {', '.join(failed)}"

        return False, f"Timeout after {timeout}s"

    # --- dashboard query helpers ---

    async def list_open_prs(self, labels: list[str]) -> list[PRListItem]:
        """Fetch open PRs for the given *labels*, deduplicated by PR number.

        Returns ``[]`` in dry-run mode or when any individual label query
        fails (the failure is silently skipped so other labels still succeed).
        """
        if self._config.dry_run:
            return []

        seen: set[int] = set()
        prs: list[PRListItem] = []

        for label in labels:
            try:
                raw = await self._run_gh(
                    "gh",
                    "pr",
                    "list",
                    "--repo",
                    self._repo,
                    "--label",
                    label,
                    "--state",
                    "open",
                    "--json",
                    "number,url,headRefName,isDraft,title",
                    "--limit",
                    "50",
                )
                for p in json.loads(raw):
                    pr_num = p["number"]
                    if pr_num in seen:
                        continue
                    seen.add(pr_num)
                    branch = p.get("headRefName", "")
                    issue_num = 0
                    if branch.startswith("agent/issue-"):
                        with contextlib.suppress(ValueError):
                            issue_num = int(branch.split("-")[-1])
                    prs.append(
                        PRListItem(
                            pr=pr_num,
                            issue=issue_num,
                            branch=branch,
                            url=p.get("url", ""),
                            draft=p.get("isDraft", False),
                            title=p.get("title", ""),
                        )
                    )
            except Exception:
                continue

        return prs

    async def list_hitl_items(self, hitl_labels: list[str]) -> list[HITLItem]:
        """Fetch HITL issues and look up their associated PRs.

        For each HITL label, fetches open issues, deduplicates by issue
        number, then looks up the associated PR via the ``agent/issue-N``
        branch convention.  Returns ``[]`` in dry-run mode or on failure.
        """
        if self._config.dry_run:
            return []

        try:
            seen_issues: set[int] = set()
            raw_issues: list[dict[str, Any]] = []

            for label in hitl_labels:
                try:
                    raw = await self._run_gh(
                        "gh",
                        "issue",
                        "list",
                        "--repo",
                        self._repo,
                        "--label",
                        label,
                        "--state",
                        "open",
                        "--json",
                        "number,title,url",
                        "--limit",
                        "50",
                    )
                    for issue in json.loads(raw):
                        if issue["number"] not in seen_issues:
                            seen_issues.add(issue["number"])
                            raw_issues.append(issue)
                except Exception:
                    continue

            items: list[HITLItem] = []
            for issue in raw_issues:
                branch = self._config.branch_for_issue(issue["number"])
                pr_number = 0
                pr_url = ""
                try:
                    pr_raw = await self._run_gh(
                        "gh",
                        "pr",
                        "list",
                        "--repo",
                        self._repo,
                        "--head",
                        branch,
                        "--state",
                        "open",
                        "--json",
                        "number,url",
                        "--limit",
                        "1",
                    )
                    pr_data = json.loads(pr_raw)
                    if pr_data:
                        pr_number = pr_data[0]["number"]
                        pr_url = pr_data[0].get("url", "")
                except Exception:
                    pass

                items.append(
                    HITLItem(
                        issue=issue["number"],
                        title=issue.get("title", ""),
                        issueUrl=issue.get("url", ""),
                        pr=pr_number,
                        prUrl=pr_url,
                        branch=branch,
                    )
                )

            return items
        except Exception:
            return []

    # --- GitHub metrics helpers ---

    _label_counts_cache: dict[str, object] = {}
    _label_counts_ts: float = 0.0

    async def _count_open_issues_by_label(
        self, label_map: dict[str, list[str]]
    ) -> dict[str, int]:
        """Count open issues for each display key in *label_map*.

        Uses the GitHub Search API (``search/issues``) which returns
        ``total_count`` directly — no pagination, scales to 10k+ issues.
        """
        open_by_label: dict[str, int] = {}
        for display_key, label_names in label_map.items():
            count = 0
            for label in label_names:
                try:
                    raw = await self._run_gh(
                        "gh",
                        "api",
                        "search/issues",
                        "-f",
                        f'q=repo:{self._repo} is:issue is:open label:"{label}"',
                        "--jq",
                        ".total_count",
                    )
                    count += int(raw.strip() or "0")
                except (RuntimeError, ValueError):
                    pass
            open_by_label[display_key] = count
        return open_by_label

    async def _count_closed_issues(self, labels: list[str]) -> int:
        """Count closed issues with any of the given *labels*.

        Uses the GitHub Search API (``search/issues``) which returns
        ``total_count`` directly — no pagination, scales to 10k+ issues.
        """
        total = 0
        for label in labels:
            try:
                raw = await self._run_gh(
                    "gh",
                    "api",
                    "search/issues",
                    "-f",
                    f'q=repo:{self._repo} is:issue is:closed label:"{label}"',
                    "--jq",
                    ".total_count",
                )
                total += int(raw.strip() or "0")
            except (RuntimeError, ValueError):
                pass
        return total

    async def _count_merged_prs(self, label: str) -> int:
        """Count merged PRs with the given *label*.

        Uses the GitHub Search API (``search/issues``) which returns
        ``total_count`` directly — no pagination, scales to 10k+ issues.
        """
        try:
            raw = await self._run_gh(
                "gh",
                "api",
                "search/issues",
                "-f",
                f'q=repo:{self._repo} is:pr is:merged label:"{label}"',
                "--jq",
                ".total_count",
            )
            return int(raw.strip() or "0")
        except (RuntimeError, ValueError):
            return 0

    async def get_label_counts(self, config: HydraFlowConfig) -> dict[str, object]:
        """Query GitHub for issue/PR counts by HydraFlow label.

        Returns a dict with ``open_by_label``, ``total_closed``, and
        ``total_merged`` keys.  Results are cached for 30 seconds.
        """
        import time

        now = time.monotonic()
        if self._label_counts_cache and now - self._label_counts_ts < 30:
            return self._label_counts_cache

        label_map = {
            "hydraflow-plan": config.planner_label,
            "hydraflow-ready": config.ready_label,
            "hydraflow-review": config.review_label,
            "hydraflow-hitl": config.hitl_label,
            "hydraflow-fixed": config.fixed_label,
        }

        open_by_label = await self._count_open_issues_by_label(label_map)
        total_closed = await self._count_closed_issues(config.fixed_label)
        fixed_label = config.fixed_label[0] if config.fixed_label else "hydraflow-fixed"
        total_merged = await self._count_merged_prs(fixed_label)

        result: dict[str, object] = {
            "open_by_label": open_by_label,
            "total_closed": total_closed,
            "total_merged": total_merged,
        }
        self._label_counts_cache = result
        self._label_counts_ts = now
        return result

    # --- body-file helpers ---

    _TRUNCATION_MARKER = "\n\n*...truncated to fit GitHub comment limit*"

    @staticmethod
    def _chunk_body(body: str, limit: int = 65_536) -> list[str]:
        """Split *body* into chunks that fit within GitHub's comment limit."""
        if len(body) <= limit:
            return [body]
        chunks: list[str] = []
        while body:
            if len(body) <= limit:
                chunks.append(body)
                break
            split_at = body.rfind("\n", 0, limit)
            if split_at <= 0:
                split_at = limit
            chunks.append(body[:split_at])
            body = body[split_at:].lstrip("\n")
        return chunks

    @classmethod
    def _cap_body(cls, body: str, limit: int = 65_536) -> str:
        """Hard-truncate *body* to *limit* characters.

        Acts as a safety net after chunking / header prepending to guarantee
        no single payload exceeds GitHub's comment size limit.
        """
        if len(body) <= limit:
            return body
        marker = cls._TRUNCATION_MARKER
        return body[: limit - len(marker)] + marker

    async def _run_with_body_file(self, *cmd: str, body: str, cwd: Path) -> str:
        """Run a ``gh`` command using ``--body-file`` instead of ``--body``.

        Writes *body* to a temporary ``.md`` file, passes ``--body-file``
        to the command, and cleans up the file afterwards.
        """
        fd, tmp_path = tempfile.mkstemp(suffix=".md", prefix="hydraflow-body-")
        try:
            with os.fdopen(fd, "w") as f:
                f.write(body)
            return await run_subprocess_with_retry(
                *cmd,
                "--body-file",
                tmp_path,
                cwd=cwd,
                gh_token=self._config.gh_token,
                max_retries=self._max_retries,
            )
        finally:
            Path(tmp_path).unlink(missing_ok=True)
