"""Pull request lifecycle management via the ``gh`` CLI."""

from __future__ import annotations

import asyncio
import json
import logging
import os
from pathlib import Path

from config import HydraConfig
from events import EventBus, EventType, HydraEvent
from models import GitHubIssue, PRInfo

logger = logging.getLogger("hydra.pr_manager")


class PRManager:
    """Pushes branches, creates PRs, merges, and manages labels."""

    # All Hydra lifecycle labels: (config_field, color, description)
    _HYDRA_LABELS: tuple[tuple[str, str, str], ...] = (
        ("planner_label", "c5def5", "Issue needs planning before implementation"),
        ("ready_label", "0e8a16", "Issue ready for implementation"),
        ("review_label", "fbca04", "Issue/PR under review"),
        ("hitl_label", "d93f0b", "Escalated to human-in-the-loop"),
        ("fixed_label", "0075ca", "PR merged — issue completed"),
    )

    def __init__(self, config: HydraConfig, event_bus: EventBus) -> None:
        self._config = config
        self._bus = event_bus
        self._repo = config.repo

    async def ensure_labels_exist(self) -> None:
        """Create all Hydra lifecycle labels in the repo if they don't exist.

        Uses ``gh label create --force`` which creates or updates each label.
        Skipped in dry-run mode.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would ensure Hydra labels exist")
            return

        for field, color, description in self._HYDRA_LABELS:
            label_name = getattr(self._config, field)
            try:
                await self._run(
                    "gh",
                    "label",
                    "create",
                    label_name,
                    "--repo",
                    self._repo,
                    "--color",
                    color,
                    "--description",
                    description,
                    "--force",
                    cwd=self._config.repo_root,
                )
                logger.debug("Ensured label %r exists", label_name)
            except RuntimeError as exc:
                logger.warning("Could not ensure label %r: %s", label_name, exc)

    async def push_branch(self, worktree_path: Path, branch: str) -> bool:
        """Push *branch* to origin from *worktree_path*.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would push branch %s", branch)
            return True

        try:
            await self._run(
                "git",
                "push",
                "-u",
                "origin",
                branch,
                cwd=worktree_path,
            )
            return True
        except RuntimeError as exc:
            logger.error("Push failed for %s: %s", branch, exc)
            return False

    async def remote_branch_exists(self, branch: str) -> bool:
        """Check whether *branch* exists on the remote."""
        if self._config.dry_run:
            return False
        try:
            output = await self._run(
                "git",
                "ls-remote",
                "--heads",
                "origin",
                branch,
                cwd=self._config.repo_root,
            )
            return bool(output.strip())
        except RuntimeError:
            return False

    async def create_pr(
        self,
        issue: GitHubIssue,
        branch: str,
        *,
        draft: bool = False,
    ) -> PRInfo:
        """Create a PR for *branch* linked to *issue*.

        Returns a :class:`PRInfo` with the PR number and URL.
        """
        title = f"Fixes #{issue.number}: {issue.title}"
        if len(title) > 70:
            title = title[:67] + "..."

        body = (
            f"## Summary\n\n"
            f"Closes #{issue.number}.\n\n"
            f"## Issue\n\n{issue.title}\n\n"
            f"## Test plan\n\n"
            f"- [ ] Unit tests pass (`make test-fast`)\n"
            f"- [ ] Linting passes (`make lint`)\n"
            f"- [ ] Manual review of changes\n\n"
            f"---\n"
            f"Generated by Hydra"
        )

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would create %sPR for issue #%d",
                "draft " if draft else "",
                issue.number,
            )
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                url="",
                draft=draft,
            )

        cmd = [
            "gh",
            "pr",
            "create",
            "--repo",
            self._repo,
            "--head",
            branch,
            "--base",
            self._config.main_branch,
            "--title",
            title,
            "--body",
            body,
        ]
        if draft:
            cmd.append("--draft")

        try:
            output = await self._run(*cmd, cwd=self._config.repo_root)
            # gh pr create --json would be better, but the URL is in stdout
            pr_url = output.strip()

            # Get PR number from URL (e.g., https://github.com/org/repo/pull/123)
            pr_number = int(pr_url.rstrip("/").split("/")[-1])

            pr_info = PRInfo(
                number=pr_number,
                issue_number=issue.number,
                branch=branch,
                url=pr_url,
                draft=draft,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.PR_CREATED,
                    data={
                        "pr": pr_number,
                        "issue": issue.number,
                        "branch": branch,
                        "draft": draft,
                        "url": pr_url,
                    },
                )
            )

            return pr_info

        except RuntimeError as exc:
            logger.error("PR creation failed for issue #%d: %s", issue.number, exc)
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                draft=draft,
            )

    async def merge_pr(self, pr_number: int) -> bool:
        """Merge PR immediately via squash merge with branch deletion.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would merge PR #%d", pr_number)
            return True

        try:
            await self._run(
                "gh",
                "pr",
                "merge",
                str(pr_number),
                "--repo",
                self._repo,
                "--squash",
                "--delete-branch",
                cwd=self._config.repo_root,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.MERGE_UPDATE,
                    data={"pr": pr_number, "status": "merged"},
                )
            )
            return True
        except RuntimeError as exc:
            logger.error("Merge failed for PR #%d: %s", pr_number, exc)
            return False

    async def post_comment(self, issue_number: int, body: str) -> None:
        """Post a comment on a GitHub issue."""
        if self._config.dry_run:
            logger.info("[dry-run] Would post comment on issue #%d", issue_number)
            return
        try:
            await self._run(
                "gh",
                "issue",
                "comment",
                str(issue_number),
                "--repo",
                self._repo,
                "--body",
                body,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not post comment on issue #%d: %s",
                issue_number,
                exc,
            )

    async def post_pr_comment(self, pr_number: int, body: str) -> None:
        """Post a comment on a GitHub pull request."""
        if self._config.dry_run:
            logger.info("[dry-run] Would post comment on PR #%d", pr_number)
            return
        try:
            await self._run(
                "gh",
                "pr",
                "comment",
                str(pr_number),
                "--repo",
                self._repo,
                "--body",
                body,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not post comment on PR #%d: %s",
                pr_number,
                exc,
            )

    async def submit_review(self, pr_number: int, verdict: str, body: str) -> bool:
        """Submit a formal GitHub PR review.

        *verdict* should be ``"approve"``, ``"request-changes"``, or
        ``"comment"``.  Returns *True* on success.
        """
        flag_map = {
            "approve": "--approve",
            "request-changes": "--request-changes",
            "comment": "--comment",
        }
        flag = flag_map.get(verdict)
        if flag is None:
            logger.error("Unknown review verdict %r for PR #%d", verdict, pr_number)
            return False

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would submit %s review on PR #%d", verdict, pr_number
            )
            return True

        try:
            await self._run(
                "gh",
                "pr",
                "review",
                str(pr_number),
                "--repo",
                self._repo,
                flag,
                "--body",
                body,
                cwd=self._config.repo_root,
            )
            return True
        except RuntimeError as exc:
            logger.error(
                "Could not submit %s review on PR #%d: %s",
                verdict,
                pr_number,
                exc,
            )
            return False

    async def add_labels(self, issue_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub issue."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await self._run(
                    "gh",
                    "issue",
                    "edit",
                    str(issue_number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to issue #%d: %s",
                    label,
                    issue_number,
                    exc,
                )

    async def remove_label(self, issue_number: int, label: str) -> None:
        """Remove *label* from a GitHub issue."""
        if self._config.dry_run:
            return
        try:
            await self._run(
                "gh",
                "issue",
                "edit",
                str(issue_number),
                "--repo",
                self._repo,
                "--remove-label",
                label,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not remove label %r from issue #%d: %s",
                label,
                issue_number,
                exc,
            )

    async def add_pr_labels(self, pr_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub pull request."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await self._run(
                    "gh",
                    "pr",
                    "edit",
                    str(pr_number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to PR #%d: %s",
                    label,
                    pr_number,
                    exc,
                )

    async def create_issue(
        self,
        title: str,
        body: str,
        labels: list[str] | None = None,
    ) -> int:
        """Create a new GitHub issue. Returns the issue number (0 on failure)."""
        if self._config.dry_run:
            logger.info("[dry-run] Would create issue: %s", title)
            return 0

        cmd = [
            "gh",
            "issue",
            "create",
            "--repo",
            self._repo,
            "--title",
            title,
            "--body",
            body,
        ]
        for label in labels or []:
            cmd.extend(["--label", label])

        try:
            output = await self._run(*cmd, cwd=self._config.repo_root)
            # gh issue create prints the issue URL
            issue_number = int(output.strip().rstrip("/").split("/")[-1])

            await self._bus.publish(
                HydraEvent(
                    type=EventType.ISSUE_CREATED,
                    data={
                        "number": issue_number,
                        "title": title,
                        "labels": labels or [],
                    },
                )
            )
            return issue_number
        except (RuntimeError, ValueError) as exc:
            logger.error("Issue creation failed for %r: %s", title, exc)
            return 0

    async def get_pr_diff(self, pr_number: int) -> str:
        """Fetch the diff for *pr_number*."""
        try:
            return await self._run(
                "gh",
                "pr",
                "diff",
                str(pr_number),
                "--repo",
                self._repo,
                cwd=self._config.repo_root,
            )
        except RuntimeError as exc:
            logger.error("Could not get diff for PR #%d: %s", pr_number, exc)
            return ""

    async def get_pr_status(self, pr_number: int) -> dict[str, object]:
        """Fetch PR status as JSON."""
        try:
            raw = await self._run(
                "gh",
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "number,state,mergeable,title,isDraft",
                cwd=self._config.repo_root,
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.error("Could not get status for PR #%d: %s", pr_number, exc)
            return {}

    async def pull_main(self) -> bool:
        """Pull latest main into the local repo."""
        if self._config.dry_run:
            logger.info("[dry-run] Would pull main")
            return True
        try:
            await self._run(
                "git",
                "pull",
                "origin",
                self._config.main_branch,
                cwd=self._config.repo_root,
            )
            return True
        except RuntimeError as exc:
            logger.error("Pull main failed: %s", exc)
            return False

    # --- CI check methods ---

    async def get_pr_checks(self, pr_number: int) -> list[dict[str, str]]:
        """Fetch CI check results for *pr_number*.

        Returns a list of dicts with ``name``, ``state``, and ``conclusion``
        keys.  Returns an empty list on failure or in dry-run mode.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would fetch CI checks for PR #%d", pr_number)
            return []

        try:
            raw = await self._run(
                "gh",
                "pr",
                "checks",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "name,state,conclusion",
                cwd=self._config.repo_root,
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.warning("Could not fetch CI checks for PR #%d: %s", pr_number, exc)
            return []

    _PASSING_CONCLUSIONS = frozenset({"SUCCESS", "NEUTRAL", "SKIPPED"})

    async def wait_for_ci(  # noqa: PLR0911
        self,
        pr_number: int,
        timeout: int,
        poll_interval: int,
        stop_event: asyncio.Event,
    ) -> tuple[bool, str]:
        """Poll CI checks until all complete or *timeout* seconds elapse.

        Returns ``(passed, summary_message)``.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would wait for CI on PR #%d", pr_number)
            return True, "Dry-run: CI skipped"

        elapsed = 0
        while elapsed < timeout:
            if stop_event.is_set():
                return False, "Stopped"

            checks = await self.get_pr_checks(pr_number)

            if not checks:
                return True, "No CI checks found"

            pending = [c for c in checks if c.get("state", "").upper() != "COMPLETED"]
            if pending:
                await self._bus.publish(
                    HydraEvent(
                        type=EventType.CI_CHECK,
                        data={
                            "pr": pr_number,
                            "status": "pending",
                            "pending": len(pending),
                            "total": len(checks),
                        },
                    )
                )
                try:
                    await asyncio.wait_for(stop_event.wait(), timeout=poll_interval)
                    # If we get here, stop_event was set
                    return False, "Stopped"
                except TimeoutError:
                    elapsed += poll_interval
                    continue

            # All checks completed — check conclusions
            failed = [
                c["name"]
                for c in checks
                if c.get("conclusion", "").upper() not in self._PASSING_CONCLUSIONS
            ]
            passed = not failed
            status = "passed" if passed else "failed"
            data: dict[str, object] = {"pr": pr_number, "status": status}
            if failed:
                data["failed"] = failed
            else:
                data["total"] = len(checks)

            await self._bus.publish(HydraEvent(type=EventType.CI_CHECK, data=data))

            if passed:
                return True, f"All {len(checks)} checks passed"
            return False, f"Failed checks: {', '.join(failed)}"

        return False, f"Timeout after {timeout}s"

    # --- subprocess helper ---

    async def _run(self, *cmd: str, cwd: Path) -> str:
        env = {**os.environ}
        env.pop("CLAUDECODE", None)
        if self._config.gh_token:
            env["GH_TOKEN"] = self._config.gh_token

        proc = await asyncio.create_subprocess_exec(
            *cmd,
            cwd=str(cwd),
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            env=env,
        )
        stdout, stderr = await proc.communicate()
        if proc.returncode != 0:
            raise RuntimeError(
                f"Command {cmd!r} failed (rc={proc.returncode}): "
                f"{stderr.decode().strip()}"
            )
        return stdout.decode().strip()
