"""Pull request lifecycle management via the ``gh`` CLI."""

from __future__ import annotations

import asyncio
import contextlib
import json
import logging
import os
import tempfile
from pathlib import Path
from typing import Any

from config import HydraConfig
from events import EventBus, EventType, HydraEvent
from models import GitHubIssue, HITLItem, PRInfo, PRListItem, ReviewVerdict
from subprocess_util import run_subprocess

logger = logging.getLogger("hydra.pr_manager")


class PRManager:
    """Pushes branches, creates PRs, merges, and manages labels."""

    _GITHUB_COMMENT_LIMIT = 65_536
    _HEADER_RESERVE = 50  # room for "*Part X/Y*\n\n" prefix

    # All Hydra lifecycle labels: (config_field, color, description)
    _HYDRA_LABELS: tuple[tuple[str, str, str], ...] = (
        ("find_label", "e4e669", "New issue for Hydra to discover and triage"),
        ("planner_label", "c5def5", "Issue needs planning before implementation"),
        ("ready_label", "0e8a16", "Issue ready for implementation"),
        ("review_label", "fbca04", "Issue/PR under review"),
        ("hitl_label", "d93f0b", "Escalated to human-in-the-loop"),
        ("hitl_active_label", "e99695", "Being processed by HITL correction agent"),
        ("fixed_label", "0075ca", "PR merged — issue completed"),
    )

    def __init__(self, config: HydraConfig, event_bus: EventBus) -> None:
        self._config = config
        self._bus = event_bus
        self._repo = config.repo

    async def ensure_labels_exist(self) -> None:
        """Create all Hydra lifecycle labels in the repo if they don't exist.

        Uses ``gh label create --force`` which creates or updates each label.
        Skipped in dry-run mode.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would ensure Hydra labels exist")
            return

        for field, color, description in self._HYDRA_LABELS:
            label_names = getattr(self._config, field)
            for label_name in label_names:
                try:
                    await run_subprocess(
                        "gh",
                        "label",
                        "create",
                        label_name,
                        "--repo",
                        self._repo,
                        "--color",
                        color,
                        "--description",
                        description,
                        "--force",
                        cwd=self._config.repo_root,
                        gh_token=self._config.gh_token,
                    )
                    logger.debug("Ensured label %r exists", label_name)
                except RuntimeError as exc:
                    logger.warning("Could not ensure label %r: %s", label_name, exc)

    async def push_branch(self, worktree_path: Path, branch: str) -> bool:
        """Push *branch* to origin from *worktree_path*.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would push branch %s", branch)
            return True

        try:
            await run_subprocess(
                "git",
                "push",
                "--no-verify",
                "-u",
                "origin",
                branch,
                cwd=worktree_path,
                gh_token=self._config.gh_token,
            )
            return True
        except RuntimeError as exc:
            logger.error("Push failed for %s: %s", branch, exc)
            return False

    async def remote_branch_exists(self, branch: str) -> bool:
        """Check whether *branch* exists on the remote."""
        if self._config.dry_run:
            return False
        try:
            output = await run_subprocess(
                "git",
                "ls-remote",
                "--heads",
                "origin",
                branch,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
            return bool(output.strip())
        except RuntimeError:
            return False

    async def create_pr(
        self,
        issue: GitHubIssue,
        branch: str,
        *,
        draft: bool = False,
    ) -> PRInfo:
        """Create a PR for *branch* linked to *issue*.

        Returns a :class:`PRInfo` with the PR number and URL.
        """
        title = f"Fixes #{issue.number}: {issue.title}"
        if len(title) > 70:
            title = title[:67] + "..."

        body = (
            f"## Summary\n\n"
            f"Closes #{issue.number}.\n\n"
            f"## Issue\n\n{issue.title}\n\n"
            f"## Test plan\n\n"
            f"- [ ] Unit tests pass (`make test`)\n"
            f"- [ ] Linting passes (`make lint`)\n"
            f"- [ ] Manual review of changes\n\n"
            f"---\n"
            f"Generated by Hydra"
        )

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would create %sPR for issue #%d",
                "draft " if draft else "",
                issue.number,
            )
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                url="",
                draft=draft,
            )

        cmd = [
            "gh",
            "pr",
            "create",
            "--repo",
            self._repo,
            "--head",
            branch,
            "--base",
            self._config.main_branch,
            "--title",
            title,
        ]
        if draft:
            cmd.append("--draft")

        try:
            output = await self._run_with_body_file(
                *cmd, body=body, cwd=self._config.repo_root
            )
            # gh pr create --json would be better, but the URL is in stdout
            pr_url = output.strip()

            # Get PR number from URL (e.g., https://github.com/org/repo/pull/123)
            pr_number = int(pr_url.rstrip("/").split("/")[-1])

            pr_info = PRInfo(
                number=pr_number,
                issue_number=issue.number,
                branch=branch,
                url=pr_url,
                draft=draft,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.PR_CREATED,
                    data={
                        "pr": pr_number,
                        "issue": issue.number,
                        "branch": branch,
                        "draft": draft,
                        "url": pr_url,
                    },
                )
            )

            return pr_info

        except RuntimeError as exc:
            logger.error("PR creation failed for issue #%d: %s", issue.number, exc)
            return PRInfo(
                number=0,
                issue_number=issue.number,
                branch=branch,
                draft=draft,
            )

    async def merge_pr(self, pr_number: int) -> bool:
        """Merge PR immediately via squash merge with branch deletion.

        Returns *True* on success.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would merge PR #%d", pr_number)
            return True

        try:
            await run_subprocess(
                "gh",
                "pr",
                "merge",
                str(pr_number),
                "--repo",
                self._repo,
                "--squash",
                "--delete-branch",
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )

            await self._bus.publish(
                HydraEvent(
                    type=EventType.MERGE_UPDATE,
                    data={"pr": pr_number, "status": "merged"},
                )
            )
            return True
        except RuntimeError as exc:
            logger.error("Merge failed for PR #%d: %s", pr_number, exc)
            return False

    async def post_comment(self, issue_number: int, body: str) -> None:
        """Post a comment on a GitHub issue."""
        if self._config.dry_run:
            logger.info("[dry-run] Would post comment on issue #%d", issue_number)
            return
        chunk_limit = self._GITHUB_COMMENT_LIMIT - self._HEADER_RESERVE
        chunks = self._chunk_body(body, chunk_limit)
        for idx, chunk in enumerate(chunks):
            part = chunk
            if len(chunks) > 1:
                part = f"*Part {idx + 1}/{len(chunks)}*\n\n{chunk}"
            part = self._cap_body(part, self._GITHUB_COMMENT_LIMIT)
            try:
                await self._run_with_body_file(
                    "gh",
                    "issue",
                    "comment",
                    str(issue_number),
                    "--repo",
                    self._repo,
                    body=part,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not post comment on issue #%d: %s",
                    issue_number,
                    exc,
                )

    async def post_pr_comment(self, pr_number: int, body: str) -> None:
        """Post a comment on a GitHub pull request."""
        if self._config.dry_run:
            logger.info("[dry-run] Would post comment on PR #%d", pr_number)
            return
        chunk_limit = self._GITHUB_COMMENT_LIMIT - self._HEADER_RESERVE
        chunks = self._chunk_body(body, chunk_limit)
        for idx, chunk in enumerate(chunks):
            part = chunk
            if len(chunks) > 1:
                part = f"*Part {idx + 1}/{len(chunks)}*\n\n{chunk}"
            part = self._cap_body(part, self._GITHUB_COMMENT_LIMIT)
            try:
                await self._run_with_body_file(
                    "gh",
                    "pr",
                    "comment",
                    str(pr_number),
                    "--repo",
                    self._repo,
                    body=part,
                    cwd=self._config.repo_root,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not post comment on PR #%d: %s",
                    pr_number,
                    exc,
                )

    async def submit_review(
        self, pr_number: int, verdict: ReviewVerdict, body: str
    ) -> bool:
        """Submit a formal GitHub PR review.

        *verdict* is a :class:`ReviewVerdict` enum member.
        Returns *True* on success.
        """
        flag_map = {
            ReviewVerdict.APPROVE: "--approve",
            ReviewVerdict.REQUEST_CHANGES: "--request-changes",
            ReviewVerdict.COMMENT: "--comment",
        }
        flag = flag_map[verdict]

        if self._config.dry_run:
            logger.info(
                "[dry-run] Would submit %s review on PR #%d",
                verdict.value,
                pr_number,
            )
            return True

        body = self._cap_body(body, self._GITHUB_COMMENT_LIMIT)
        try:
            await self._run_with_body_file(
                "gh",
                "pr",
                "review",
                str(pr_number),
                "--repo",
                self._repo,
                flag,
                body=body,
                cwd=self._config.repo_root,
            )
            return True
        except RuntimeError as exc:
            logger.error(
                "Could not submit %s review on PR #%d: %s",
                verdict.value,
                pr_number,
                exc,
            )
            return False

    async def add_labels(self, issue_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub issue."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await run_subprocess(
                    "gh",
                    "issue",
                    "edit",
                    str(issue_number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                    cwd=self._config.repo_root,
                    gh_token=self._config.gh_token,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to issue #%d: %s",
                    label,
                    issue_number,
                    exc,
                )

    async def remove_label(self, issue_number: int, label: str) -> None:
        """Remove *label* from a GitHub issue."""
        if self._config.dry_run:
            return
        try:
            await run_subprocess(
                "gh",
                "issue",
                "edit",
                str(issue_number),
                "--repo",
                self._repo,
                "--remove-label",
                label,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not remove label %r from issue #%d: %s",
                label,
                issue_number,
                exc,
            )

    async def close_issue(self, issue_number: int) -> None:
        """Close a GitHub issue."""
        if self._config.dry_run:
            return
        try:
            await run_subprocess(
                "gh",
                "issue",
                "close",
                str(issue_number),
                "--repo",
                self._repo,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not close issue #%d: %s",
                issue_number,
                exc,
            )

    async def remove_pr_label(self, pr_number: int, label: str) -> None:
        """Remove *label* from a GitHub pull request."""
        if self._config.dry_run:
            return
        try:
            await run_subprocess(
                "gh",
                "pr",
                "edit",
                str(pr_number),
                "--repo",
                self._repo,
                "--remove-label",
                label,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
        except RuntimeError as exc:
            logger.warning(
                "Could not remove label %r from PR #%d: %s",
                label,
                pr_number,
                exc,
            )

    async def add_pr_labels(self, pr_number: int, labels: list[str]) -> None:
        """Add *labels* to a GitHub pull request."""
        if self._config.dry_run or not labels:
            return
        for label in labels:
            try:
                await run_subprocess(
                    "gh",
                    "pr",
                    "edit",
                    str(pr_number),
                    "--repo",
                    self._repo,
                    "--add-label",
                    label,
                    cwd=self._config.repo_root,
                    gh_token=self._config.gh_token,
                )
            except RuntimeError as exc:
                logger.warning(
                    "Could not add label %r to PR #%d: %s",
                    label,
                    pr_number,
                    exc,
                )

    async def create_issue(
        self,
        title: str,
        body: str,
        labels: list[str] | None = None,
    ) -> int:
        """Create a new GitHub issue. Returns the issue number (0 on failure)."""
        if self._config.dry_run:
            logger.info("[dry-run] Would create issue: %s", title)
            return 0

        cmd = [
            "gh",
            "issue",
            "create",
            "--repo",
            self._repo,
            "--title",
            title,
        ]
        for label in labels or []:
            cmd.extend(["--label", label])

        try:
            output = await self._run_with_body_file(
                *cmd, body=body, cwd=self._config.repo_root
            )
            # gh issue create prints the issue URL
            issue_number = int(output.strip().rstrip("/").split("/")[-1])

            await self._bus.publish(
                HydraEvent(
                    type=EventType.ISSUE_CREATED,
                    data={
                        "number": issue_number,
                        "title": title,
                        "labels": labels or [],
                    },
                )
            )
            return issue_number
        except (RuntimeError, ValueError) as exc:
            logger.error("Issue creation failed for %r: %s", title, exc)
            return 0

    async def get_pr_diff(self, pr_number: int) -> str:
        """Fetch the diff for *pr_number*."""
        try:
            return await run_subprocess(
                "gh",
                "pr",
                "diff",
                str(pr_number),
                "--repo",
                self._repo,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
        except RuntimeError as exc:
            logger.error("Could not get diff for PR #%d: %s", pr_number, exc)
            return ""

    async def get_pr_status(self, pr_number: int) -> dict[str, object]:
        """Fetch PR status as JSON."""
        try:
            raw = await run_subprocess(
                "gh",
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "number,state,mergeable,title,isDraft",
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.error("Could not get status for PR #%d: %s", pr_number, exc)
            return {}

    async def pull_main(self) -> bool:
        """Pull latest main into the local repo."""
        if self._config.dry_run:
            logger.info("[dry-run] Would pull main")
            return True
        try:
            await run_subprocess(
                "git",
                "pull",
                "origin",
                self._config.main_branch,
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
            return True
        except RuntimeError as exc:
            logger.error("Pull main failed: %s", exc)
            return False

    # --- CI check methods ---

    async def get_pr_checks(self, pr_number: int) -> list[dict[str, str]]:
        """Fetch CI check results for *pr_number*.

        Returns a list of dicts with ``name`` and ``state`` keys.
        Returns an empty list on failure or in dry-run mode.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would fetch CI checks for PR #%d", pr_number)
            return []

        try:
            raw = await run_subprocess(
                "gh",
                "pr",
                "checks",
                str(pr_number),
                "--repo",
                self._repo,
                "--json",
                "name,state",
                cwd=self._config.repo_root,
                gh_token=self._config.gh_token,
            )
            return json.loads(raw)  # type: ignore[no-any-return]
        except (RuntimeError, json.JSONDecodeError) as exc:
            logger.warning("Could not fetch CI checks for PR #%d: %s", pr_number, exc)
            return []

    _PASSING_STATES = frozenset({"SUCCESS", "NEUTRAL", "SKIPPED"})
    _PENDING_STATES = frozenset(
        {"PENDING", "QUEUED", "IN_PROGRESS", "REQUESTED", "WAITING"}
    )

    async def wait_for_ci(  # noqa: PLR0911
        self,
        pr_number: int,
        timeout: int,
        poll_interval: int,
        stop_event: asyncio.Event,
    ) -> tuple[bool, str]:
        """Poll CI checks until all complete or *timeout* seconds elapse.

        Returns ``(passed, summary_message)``.
        """
        if self._config.dry_run:
            logger.info("[dry-run] Would wait for CI on PR #%d", pr_number)
            return True, "Dry-run: CI skipped"

        elapsed = 0
        while elapsed < timeout:
            if stop_event.is_set():
                return False, "Stopped"

            checks = await self.get_pr_checks(pr_number)

            if not checks:
                return True, "No CI checks found"

            pending = [
                c for c in checks if c.get("state", "").upper() in self._PENDING_STATES
            ]
            if pending:
                await self._bus.publish(
                    HydraEvent(
                        type=EventType.CI_CHECK,
                        data={
                            "pr": pr_number,
                            "status": "pending",
                            "pending": len(pending),
                            "total": len(checks),
                        },
                    )
                )
                try:
                    await asyncio.wait_for(stop_event.wait(), timeout=poll_interval)
                    # If we get here, stop_event was set
                    return False, "Stopped"
                except TimeoutError:
                    elapsed += poll_interval
                    continue

            # All checks completed — check states
            failed = [
                c["name"]
                for c in checks
                if c.get("state", "").upper() not in self._PASSING_STATES
            ]
            passed = not failed
            status = "passed" if passed else "failed"
            data: dict[str, object] = {"pr": pr_number, "status": status}
            if failed:
                data["failed"] = failed
            else:
                data["total"] = len(checks)

            await self._bus.publish(HydraEvent(type=EventType.CI_CHECK, data=data))

            if passed:
                return True, f"All {len(checks)} checks passed"
            return False, f"Failed checks: {', '.join(failed)}"

        return False, f"Timeout after {timeout}s"

    # --- dashboard query helpers ---

    async def list_open_prs(self, labels: list[str]) -> list[PRListItem]:
        """Fetch open PRs for the given *labels*, deduplicated by PR number.

        Returns ``[]`` in dry-run mode or when any individual label query
        fails (the failure is silently skipped so other labels still succeed).
        """
        if self._config.dry_run:
            return []

        seen: set[int] = set()
        prs: list[PRListItem] = []

        for label in labels:
            try:
                raw = await run_subprocess(
                    "gh",
                    "pr",
                    "list",
                    "--repo",
                    self._repo,
                    "--label",
                    label,
                    "--state",
                    "open",
                    "--json",
                    "number,url,headRefName,isDraft,title",
                    "--limit",
                    "50",
                    cwd=self._config.repo_root,
                    gh_token=self._config.gh_token,
                )
                for p in json.loads(raw):
                    pr_num = p["number"]
                    if pr_num in seen:
                        continue
                    seen.add(pr_num)
                    branch = p.get("headRefName", "")
                    issue_num = 0
                    if branch.startswith("agent/issue-"):
                        with contextlib.suppress(ValueError):
                            issue_num = int(branch.split("-")[-1])
                    prs.append(
                        PRListItem(
                            pr=pr_num,
                            issue=issue_num,
                            branch=branch,
                            url=p.get("url", ""),
                            draft=p.get("isDraft", False),
                            title=p.get("title", ""),
                        )
                    )
            except Exception:
                continue

        return prs

    async def list_hitl_items(self, hitl_labels: list[str]) -> list[HITLItem]:
        """Fetch HITL issues and look up their associated PRs.

        For each HITL label, fetches open issues, deduplicates by issue
        number, then looks up the associated PR via the ``agent/issue-N``
        branch convention.  Returns ``[]`` in dry-run mode or on failure.
        """
        if self._config.dry_run:
            return []

        try:
            seen_issues: set[int] = set()
            raw_issues: list[dict[str, Any]] = []

            for label in hitl_labels:
                try:
                    raw = await run_subprocess(
                        "gh",
                        "issue",
                        "list",
                        "--repo",
                        self._repo,
                        "--label",
                        label,
                        "--state",
                        "open",
                        "--json",
                        "number,title,url",
                        "--limit",
                        "50",
                        cwd=self._config.repo_root,
                        gh_token=self._config.gh_token,
                    )
                    for issue in json.loads(raw):
                        if issue["number"] not in seen_issues:
                            seen_issues.add(issue["number"])
                            raw_issues.append(issue)
                except Exception:
                    continue

            items: list[HITLItem] = []
            for issue in raw_issues:
                branch = self._config.branch_for_issue(issue["number"])
                pr_number = 0
                pr_url = ""
                try:
                    pr_raw = await run_subprocess(
                        "gh",
                        "pr",
                        "list",
                        "--repo",
                        self._repo,
                        "--head",
                        branch,
                        "--state",
                        "open",
                        "--json",
                        "number,url",
                        "--limit",
                        "1",
                        cwd=self._config.repo_root,
                        gh_token=self._config.gh_token,
                    )
                    pr_data = json.loads(pr_raw)
                    if pr_data:
                        pr_number = pr_data[0]["number"]
                        pr_url = pr_data[0].get("url", "")
                except Exception:
                    pass

                items.append(
                    HITLItem(
                        issue=issue["number"],
                        title=issue.get("title", ""),
                        issueUrl=issue.get("url", ""),
                        pr=pr_number,
                        prUrl=pr_url,
                        branch=branch,
                    )
                )

            return items
        except Exception:
            return []

    # --- body-file helpers ---

    _TRUNCATION_MARKER = "\n\n*...truncated to fit GitHub comment limit*"

    @staticmethod
    def _chunk_body(body: str, limit: int = 65_536) -> list[str]:
        """Split *body* into chunks that fit within GitHub's comment limit."""
        if len(body) <= limit:
            return [body]
        chunks: list[str] = []
        while body:
            if len(body) <= limit:
                chunks.append(body)
                break
            split_at = body.rfind("\n", 0, limit)
            if split_at <= 0:
                split_at = limit
            chunks.append(body[:split_at])
            body = body[split_at:].lstrip("\n")
        return chunks

    @classmethod
    def _cap_body(cls, body: str, limit: int = 65_536) -> str:
        """Hard-truncate *body* to *limit* characters.

        Acts as a safety net after chunking / header prepending to guarantee
        no single payload exceeds GitHub's comment size limit.
        """
        if len(body) <= limit:
            return body
        marker = cls._TRUNCATION_MARKER
        return body[: limit - len(marker)] + marker

    async def _run_with_body_file(self, *cmd: str, body: str, cwd: Path) -> str:
        """Run a ``gh`` command using ``--body-file`` instead of ``--body``.

        Writes *body* to a temporary ``.md`` file, passes ``--body-file``
        to the command, and cleans up the file afterwards.
        """
        fd, tmp_path = tempfile.mkstemp(suffix=".md", prefix="hydra-body-")
        try:
            with os.fdopen(fd, "w") as f:
                f.write(body)
            return await run_subprocess(
                *cmd,
                "--body-file",
                tmp_path,
                cwd=cwd,
                gh_token=self._config.gh_token,
            )
        finally:
            Path(tmp_path).unlink(missing_ok=True)
