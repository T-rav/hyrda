"""PDF generation utility for research reports.

Converts markdown reports to professionally styled PDFs with proper formatting,
citations, and metadata.

Requires: weasyprint, markdown (installed as default dependencies)
"""

import logging
from datetime import datetime
from io import BytesIO
from typing import Any

import markdown
from weasyprint import HTML

logger = logging.getLogger(__name__)


def markdown_to_pdf(
    markdown_content: str,
    title: str,
    metadata: dict[str, Any] | None = None,
    style: str = "professional",
) -> BytesIO | None:
    """Convert markdown content to a styled PDF.

    Args:
        markdown_content: The markdown text to convert
        title: Report title
        metadata: Optional metadata (author, date, profile_type, etc.)
        style: Style preset ('minimal', 'professional', 'detailed')

    Returns:
        BytesIO containing the PDF, or None if generation fails
    """
    try:
        # Convert markdown to HTML
        md = markdown.Markdown(
            extensions=[
                "extra",  # Tables, fenced code, footnotes
                "nl2br",  # Newline to <br>
                "sane_lists",  # Better list handling
                "codehilite",  # Code syntax highlighting
                "toc",  # Table of contents
            ]
        )
        content_html = md.convert(markdown_content)

        # Build complete HTML document with styling
        html_content = _build_html_document(
            content_html=content_html,
            title=title,
            metadata=metadata or {},
            style=style,
        )

        # Generate PDF
        pdf_bytes = BytesIO()
        HTML(string=html_content).write_pdf(pdf_bytes)
        pdf_bytes.seek(0)

        logger.info(f"Generated PDF: {title} ({pdf_bytes.getbuffer().nbytes} bytes)")
        return pdf_bytes

    except Exception as e:
        logger.error(f"PDF generation failed: {e}", exc_info=True)
        return None


def _build_html_document(
    content_html: str,
    title: str,
    metadata: dict[str, Any],
    style: str,
) -> str:
    """Build complete HTML document with styling.

    Args:
        content_html: Converted markdown HTML
        title: Document title
        metadata: Document metadata
        style: Style preset

    Returns:
        Complete HTML document string
    """
    # Get CSS based on style
    css = _get_css_for_style(style)

    # Build metadata section
    metadata_html = _build_metadata_section(metadata)

    # Generate timestamp
    timestamp = datetime.now().strftime("%B %d, %Y at %I:%M %p")

    return f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        {css}
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">{title}</h1>
        {metadata_html}
        <div class="timestamp">Generated: {timestamp}</div>
    </div>

    <div class="content">
        {content_html}
    </div>
</body>
</html>
"""


def _build_metadata_section(metadata: dict[str, Any]) -> str:
    """Build HTML for metadata section.

    Args:
        metadata: Metadata dictionary

    Returns:
        HTML string for metadata section
    """
    if not metadata:
        return ""

    items = []

    # Profile type
    if profile_type := metadata.get("profile_type"):
        items.append(f"<strong>Type:</strong> {profile_type.title()}")

    # Agent
    if agent := metadata.get("agent"):
        items.append(f"<strong>Agent:</strong> {agent.title()}")

    # Research notes count
    if notes_count := metadata.get("research_notes"):
        items.append(f"<strong>Sources:</strong> {notes_count} research notes")

    # Report length
    if report_length := metadata.get("report_length"):
        items.append(f"<strong>Length:</strong> {report_length:,} characters")

    if not items:
        return ""

    return f'<div class="metadata">{" | ".join(items)}</div>'


def _get_css_for_style(style: str) -> str:
    """Get CSS styling based on preset.

    Args:
        style: Style preset name

    Returns:
        CSS string
    """
    # Base styles (common to all presets)
    base_css = """
        @page {
            size: Letter;
            margin: 1in 0.75in;
            @bottom-left {
                content: "Generated by InsightMesh";
                font-size: 9pt;
                color: #666;
            }
            @bottom-right {
                content: "Page " counter(page) " of " counter(pages);
                font-size: 9pt;
                color: #666;
            }
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 100%;
        }

        .header {
            border-bottom: 3px solid #2C5282;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }

        .title {
            font-size: 28pt;
            font-weight: 700;
            color: #1A365D;
            margin: 0 0 10px 0;
        }

        .metadata {
            font-size: 10pt;
            color: #666;
            margin-top: 8px;
        }

        .timestamp {
            font-size: 9pt;
            color: #999;
            margin-top: 8px;
            font-style: italic;
        }

        .content {
            font-size: 11pt;
        }

        h2 {
            font-size: 18pt;
            font-weight: 700;
            color: #2C5282;
            margin-top: 24px;
            margin-bottom: 12px;
            border-bottom: 2px solid #E2E8F0;
            padding-bottom: 6px;
        }

        h3 {
            font-size: 14pt;
            font-weight: 600;
            color: #2D3748;
            margin-top: 18px;
            margin-bottom: 10px;
        }

        h4 {
            font-size: 12pt;
            font-weight: 600;
            color: #4A5568;
            margin-top: 14px;
            margin-bottom: 8px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
        }

        ul, ol {
            margin: 10px 0;
            padding-left: 24px;
        }

        li {
            margin: 6px 0;
        }

        code {
            background-color: #F7FAFC;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 10pt;
            color: #C53030;
        }

        pre {
            background-color: #F7FAFC;
            border: 1px solid #E2E8F0;
            border-radius: 4px;
            padding: 12px;
            overflow-x: auto;
            margin: 12px 0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
            color: #2D3748;
        }

        blockquote {
            border-left: 4px solid #CBD5E0;
            margin: 12px 0;
            padding-left: 16px;
            color: #4A5568;
            font-style: italic;
        }

        a {
            color: #2C5282;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Citation links */
        a[href^="#"] {
            color: #2C5282;
            font-weight: 600;
            text-decoration: none;
            font-size: 9pt;
            vertical-align: super;
        }

        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
        }

        th, td {
            border: 1px solid #E2E8F0;
            padding: 8px 12px;
            text-align: left;
        }

        th {
            background-color: #EDF2F7;
            font-weight: 600;
            color: #2D3748;
        }

        /* Page breaks */
        h2 {
            page-break-before: avoid;
            page-break-after: avoid;
        }

        h3, h4 {
            page-break-after: avoid;
        }

        /* Keep MEDDPICC field sections together (h3 + following content) */
        h3 {
            page-break-inside: avoid;
        }

        /* Allow page breaks between MEDDPICC sections but not within them */
        h3 + p, h3 + ul {
            page-break-before: avoid;
        }

        /* Allow page breaks for long lists (like Sources section) */
        ul, ol {
            page-break-inside: auto;
        }

        /* Keep short lists together (5 items or less) */
        ul li:first-child:nth-last-child(-n+5),
        ol li:first-child:nth-last-child(-n+5) {
            page-break-inside: avoid;
        }

        /* Keep horizontal rules with surrounding content */
        hr {
            page-break-after: avoid;
        }
    """

    if style == "minimal":
        return base_css

    if style == "professional":
        return (
            base_css
            + """
        .content {
            text-align: justify;
        }

        h2::before {
            content: "â–  ";
            color: #2C5282;
        }
        """
        )

    if style == "detailed":
        return (
            base_css
            + """
        .content {
            text-align: justify;
        }

        h2 {
            background-color: #EDF2F7;
            padding: 12px;
            border-left: 5px solid #2C5282;
            border-bottom: none;
        }

        h3 {
            border-left: 3px solid #CBD5E0;
            padding-left: 12px;
        }
        """
        )

    return base_css


def get_pdf_filename(title: str, profile_type: str = "profile") -> str:
    """Generate a safe filename for the PDF.

    Args:
        title: Report title
        profile_type: Profile type (company, employee, project)

    Returns:
        Safe filename string
    """
    # Clean title for filename
    safe_title = "".join(
        c for c in title if c.isalnum() or c in (" ", "-", "_")
    ).strip()
    safe_title = safe_title.replace(" ", "_")[:50]  # Limit length

    # Add timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    return f"{profile_type}_{safe_title}_{timestamp}.pdf"
